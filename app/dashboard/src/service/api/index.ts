/**
 * Generated by orval v7.4.1 ðŸº
 * Do not edit manually.
 * MarzbanAPI
 * Unified GUI Censorship Resistant Solution Powered by Xray
 * OpenAPI spec version: 0.7.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import { orvalFetcher } from "../http";
import type { ErrorType, BodyType } from "../http";
export type GetUserTemplatesParams = {
  offset?: number;
  limit?: number;
};

export type UserGetUsageParams = {
  start?: string;
  end?: string;
};

export type DeleteExpiredUsersParams = {
  expired_after?: string | null;
  expired_before?: string | null;
};

export type GetExpiredUsersParams = {
  expired_after?: string | null;
  expired_before?: string | null;
};

export type SetOwnerParams = {
  admin_username: string;
};

export type GetUsersUsageParams = {
  start?: string;
  end?: string;
  admin?: string[] | null;
};

export type GetUserUsageParams = {
  start?: string;
  end?: string;
};

export type GetUsersParams = {
  offset?: number;
  limit?: number;
  username?: string[];
  search?: string | null;
  admin?: string[] | null;
  status?: UserStatus;
  sort?: string;
};

export type GetUsageParams = {
  start?: string;
  end?: string;
};

export type GetHostsParams = {
  offset?: number;
  limit?: number;
};

export type ModifyCoreConfig200 = { [key: string]: unknown };

export type ModifyCoreConfigBody = { [key: string]: unknown };

export type GetCoreConfig200 = { [key: string]: unknown };

export type GetInbounds200 = { [key: string]: ProxyInbound[] };

export type GetAdminsParams = {
  offset?: number | null;
  limit?: number | null;
  username?: string | null;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface UsersUsagesResponse {
  usages: UserUsageResponse[];
}

export interface UsersResponse {
  users: UserResponse[];
  total: number;
}

export type UserUsageResponseNodeId = number | null;

export interface UserUsageResponse {
  node_id?: UserUsageResponseNodeId;
  node_name: string;
  used_traffic: number;
}

export interface UserUsagesResponse {
  username: string;
  usages: UserUsageResponse[];
}

export type UserTemplateResponseInbounds = { [key: string]: string[] };

export type UserTemplateResponseUsernameSuffix = string | null;

export type UserTemplateResponseUsernamePrefix = string | null;

/**
 * expire_duration can be 0 or greater in seconds
 */
export type UserTemplateResponseExpireDuration = number | null;

/**
 * data_limit can be 0 or greater
 */
export type UserTemplateResponseDataLimit = number | null;

/**
 * @nullable
 */
export type UserTemplateResponseName = string | null | null;

export interface UserTemplateResponse {
  /** @nullable */
  name?: UserTemplateResponseName;
  /** data_limit can be 0 or greater */
  data_limit?: UserTemplateResponseDataLimit;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: UserTemplateResponseExpireDuration;
  username_prefix?: UserTemplateResponseUsernamePrefix;
  username_suffix?: UserTemplateResponseUsernameSuffix;
  inbounds?: UserTemplateResponseInbounds;
  id: number;
}

export type UserTemplateModifyInbounds = { [key: string]: string[] };

export type UserTemplateModifyUsernameSuffix = string | null;

export type UserTemplateModifyUsernamePrefix = string | null;

/**
 * expire_duration can be 0 or greater in seconds
 */
export type UserTemplateModifyExpireDuration = number | null;

/**
 * data_limit can be 0 or greater
 */
export type UserTemplateModifyDataLimit = number | null;

/**
 * @nullable
 */
export type UserTemplateModifyName = string | null | null;

export interface UserTemplateModify {
  /** @nullable */
  name?: UserTemplateModifyName;
  /** data_limit can be 0 or greater */
  data_limit?: UserTemplateModifyDataLimit;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: UserTemplateModifyExpireDuration;
  username_prefix?: UserTemplateModifyUsernamePrefix;
  username_suffix?: UserTemplateModifyUsernameSuffix;
  inbounds?: UserTemplateModifyInbounds;
}

export type UserTemplateCreateInbounds = { [key: string]: string[] };

export type UserTemplateCreateUsernameSuffix = string | null;

export type UserTemplateCreateUsernamePrefix = string | null;

/**
 * expire_duration can be 0 or greater in seconds
 */
export type UserTemplateCreateExpireDuration = number | null;

/**
 * data_limit can be 0 or greater
 */
export type UserTemplateCreateDataLimit = number | null;

/**
 * @nullable
 */
export type UserTemplateCreateName = string | null | null;

export interface UserTemplateCreate {
  /** @nullable */
  name?: UserTemplateCreateName;
  /** data_limit can be 0 or greater */
  data_limit?: UserTemplateCreateDataLimit;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: UserTemplateCreateExpireDuration;
  username_prefix?: UserTemplateCreateUsernamePrefix;
  username_suffix?: UserTemplateCreateUsernameSuffix;
  inbounds?: UserTemplateCreateInbounds;
}

export type UserStatusModify =
  (typeof UserStatusModify)[keyof typeof UserStatusModify];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatusModify = {
  active: "active",
  disabled: "disabled",
  on_hold: "on_hold",
} as const;

export type UserStatusCreate =
  (typeof UserStatusCreate)[keyof typeof UserStatusCreate];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatusCreate = {
  active: "active",
  on_hold: "on_hold",
} as const;

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatus = {
  active: "active",
  disabled: "disabled",
  limited: "limited",
  expired: "expired",
  on_hold: "on_hold",
} as const;

export type UserResponseAdmin = Admin | null;

export type UserResponseExcludedInbounds = { [key: string]: string[] };

/**
 * @nullable
 */
export type UserResponseNextPlan = NextPlanModel | null | null;

/**
 * @nullable
 */
export type UserResponseAutoDeleteInDays = number | null | null;

/**
 * @nullable
 */
export type UserResponseOnHoldTimeout = string | number | null | null;

/**
 * @nullable
 */
export type UserResponseOnHoldExpireDuration = number | null | null;

/**
 * @nullable
 */
export type UserResponseOnlineAt = string | null | null;

/**
 * @nullable
 */
export type UserResponseSubLastUserAgent = string | null | null;

/**
 * @nullable
 */
export type UserResponseSubUpdatedAt = string | null | null;

/**
 * @nullable
 */
export type UserResponseNote = string | null | null;

export type UserResponseInbounds = { [key: string]: string[] };

/**
 * data_limit can be 0 or greater
 */
export type UserResponseDataLimit = number | null;

/**
 * @nullable
 */
export type UserResponseExpire = string | number | null | null;

export type UserResponseProxies = { [key: string]: unknown };

export interface UserResponse {
  proxies: UserResponseProxies;
  /** @nullable */
  expire?: UserResponseExpire;
  /** data_limit can be 0 or greater */
  data_limit?: UserResponseDataLimit;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  inbounds?: UserResponseInbounds;
  /** @nullable */
  note?: UserResponseNote;
  /** @nullable */
  sub_updated_at?: UserResponseSubUpdatedAt;
  /** @nullable */
  sub_last_user_agent?: UserResponseSubLastUserAgent;
  /** @nullable */
  online_at?: UserResponseOnlineAt;
  /** @nullable */
  on_hold_expire_duration?: UserResponseOnHoldExpireDuration;
  /** @nullable */
  on_hold_timeout?: UserResponseOnHoldTimeout;
  /** @nullable */
  auto_delete_in_days?: UserResponseAutoDeleteInDays;
  /** @nullable */
  next_plan?: UserResponseNextPlan;
  username: string;
  status: UserStatus;
  used_traffic: number;
  lifetime_used_traffic?: number;
  created_at: string;
  subscription_url?: string;
  excluded_inbounds?: UserResponseExcludedInbounds;
  admin?: UserResponseAdmin;
}

/**
 * @nullable
 */
export type UserModifyNextPlan = NextPlanModel | null | null;

/**
 * @nullable
 */
export type UserModifyAutoDeleteInDays = number | null | null;

/**
 * @nullable
 */
export type UserModifyOnHoldTimeout = string | number | null | null;

/**
 * @nullable
 */
export type UserModifyOnHoldExpireDuration = number | null | null;

/**
 * @nullable
 */
export type UserModifyOnlineAt = string | null | null;

/**
 * @nullable
 */
export type UserModifySubLastUserAgent = string | null | null;

/**
 * @nullable
 */
export type UserModifySubUpdatedAt = string | null | null;

/**
 * @nullable
 */
export type UserModifyNote = string | null | null;

export type UserModifyInbounds = { [key: string]: string[] };

/**
 * data_limit can be 0 or greater
 */
export type UserModifyDataLimit = number | null;

/**
 * @nullable
 */
export type UserModifyExpire = string | number | null | null;

export type UserModifyProxies = { [key: string]: ProxySettings };

export type UserDataLimitResetStrategy =
  (typeof UserDataLimitResetStrategy)[keyof typeof UserDataLimitResetStrategy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserDataLimitResetStrategy = {
  no_reset: "no_reset",
  day: "day",
  week: "week",
  month: "month",
  year: "year",
} as const;

export interface UserModify {
  proxies?: UserModifyProxies;
  /** @nullable */
  expire?: UserModifyExpire;
  /** data_limit can be 0 or greater */
  data_limit?: UserModifyDataLimit;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  inbounds?: UserModifyInbounds;
  /** @nullable */
  note?: UserModifyNote;
  /** @nullable */
  sub_updated_at?: UserModifySubUpdatedAt;
  /** @nullable */
  sub_last_user_agent?: UserModifySubLastUserAgent;
  /** @nullable */
  online_at?: UserModifyOnlineAt;
  /** @nullable */
  on_hold_expire_duration?: UserModifyOnHoldExpireDuration;
  /** @nullable */
  on_hold_timeout?: UserModifyOnHoldTimeout;
  /** @nullable */
  auto_delete_in_days?: UserModifyAutoDeleteInDays;
  /** @nullable */
  next_plan?: UserModifyNextPlan;
  status?: UserStatusModify;
}

/**
 * @nullable
 */
export type UserCreateNextPlan = NextPlanModel | null | null;

/**
 * @nullable
 */
export type UserCreateAutoDeleteInDays = number | null | null;

/**
 * @nullable
 */
export type UserCreateOnHoldTimeout = string | number | null | null;

/**
 * @nullable
 */
export type UserCreateOnHoldExpireDuration = number | null | null;

/**
 * @nullable
 */
export type UserCreateOnlineAt = string | null | null;

/**
 * @nullable
 */
export type UserCreateSubLastUserAgent = string | null | null;

/**
 * @nullable
 */
export type UserCreateSubUpdatedAt = string | null | null;

/**
 * @nullable
 */
export type UserCreateNote = string | null | null;

export type UserCreateInbounds = { [key: string]: string[] };

/**
 * data_limit can be 0 or greater
 */
export type UserCreateDataLimit = number | null;

/**
 * @nullable
 */
export type UserCreateExpire = string | number | null | null;

export type UserCreateProxies = { [key: string]: ProxySettings };

export interface UserCreate {
  proxies?: UserCreateProxies;
  /** @nullable */
  expire?: UserCreateExpire;
  /** data_limit can be 0 or greater */
  data_limit?: UserCreateDataLimit;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  inbounds?: UserCreateInbounds;
  /** @nullable */
  note?: UserCreateNote;
  /** @nullable */
  sub_updated_at?: UserCreateSubUpdatedAt;
  /** @nullable */
  sub_last_user_agent?: UserCreateSubLastUserAgent;
  /** @nullable */
  online_at?: UserCreateOnlineAt;
  /** @nullable */
  on_hold_expire_duration?: UserCreateOnHoldExpireDuration;
  /** @nullable */
  on_hold_timeout?: UserCreateOnHoldTimeout;
  /** @nullable */
  auto_delete_in_days?: UserCreateAutoDeleteInDays;
  /** @nullable */
  next_plan?: UserCreateNextPlan;
  username: string;
  status?: UserStatusCreate;
}

export interface Unauthorized {
  detail?: string;
}

export interface Token {
  access_token: string;
  token_type?: string;
}

export interface SystemStats {
  version: string;
  mem_total: number;
  mem_used: number;
  cpu_cores: number;
  cpu_usage: number;
  total_user: number;
  online_users: number;
  users_active: number;
  users_on_hold: number;
  users_disabled: number;
  users_expired: number;
  users_limited: number;
  incoming_bandwidth: number;
  outgoing_bandwidth: number;
  incoming_bandwidth_speed: number;
  outgoing_bandwidth_speed: number;
}

/**
 * @nullable
 */
export type SubscriptionUserResponseNextPlan = NextPlanModel | null | null;

/**
 * @nullable
 */
export type SubscriptionUserResponseOnHoldTimeout =
  | string
  | number
  | null
  | null;

/**
 * @nullable
 */
export type SubscriptionUserResponseOnHoldExpireDuration = number | null | null;

/**
 * @nullable
 */
export type SubscriptionUserResponseOnlineAt = string | null | null;

/**
 * @nullable
 */
export type SubscriptionUserResponseSubLastUserAgent = string | null | null;

/**
 * @nullable
 */
export type SubscriptionUserResponseSubUpdatedAt = string | null | null;

/**
 * data_limit can be 0 or greater
 */
export type SubscriptionUserResponseDataLimit = number | null;

/**
 * @nullable
 */
export type SubscriptionUserResponseExpire = string | number | null | null;

export type SubscriptionUserResponseProxies = { [key: string]: unknown };

export interface SubscriptionUserResponse {
  proxies: SubscriptionUserResponseProxies;
  /** @nullable */
  expire?: SubscriptionUserResponseExpire;
  /** data_limit can be 0 or greater */
  data_limit?: SubscriptionUserResponseDataLimit;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  /** @nullable */
  sub_updated_at?: SubscriptionUserResponseSubUpdatedAt;
  /** @nullable */
  sub_last_user_agent?: SubscriptionUserResponseSubLastUserAgent;
  /** @nullable */
  online_at?: SubscriptionUserResponseOnlineAt;
  /** @nullable */
  on_hold_expire_duration?: SubscriptionUserResponseOnHoldExpireDuration;
  /** @nullable */
  on_hold_timeout?: SubscriptionUserResponseOnHoldTimeout;
  /** @nullable */
  next_plan?: SubscriptionUserResponseNextPlan;
  username: string;
  status: UserStatus;
  used_traffic: number;
  lifetime_used_traffic?: number;
  created_at: string;
  subscription_url?: string;
}

export type ProxyTypes = (typeof ProxyTypes)[keyof typeof ProxyTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyTypes = {
  vmess: "vmess",
  vless: "vless",
  trojan: "trojan",
  shadowsocks: "shadowsocks",
} as const;

export interface ProxySettings {
  [key: string]: unknown;
}

export type ProxyInboundPort = number | string;

export interface ProxyInbound {
  tag: string;
  protocol: ProxyTypes;
  network: string;
  tls: string;
  port: ProxyInboundPort;
}

export type ProxyHostSecurity =
  (typeof ProxyHostSecurity)[keyof typeof ProxyHostSecurity];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostSecurity = {
  inbound_default: "inbound_default",
  none: "none",
  tls: "tls",
} as const;

export type ProxyHostFingerprint =
  (typeof ProxyHostFingerprint)[keyof typeof ProxyHostFingerprint];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostFingerprint = {
  "": "",
  chrome: "chrome",
  firefox: "firefox",
  safari: "safari",
  ios: "ios",
  android: "android",
  edge: "edge",
  NUMBER_360: "360",
  qq: "qq",
  random: "random",
  randomized: "randomized",
} as const;

export type ProxyHostALPN = (typeof ProxyHostALPN)[keyof typeof ProxyHostALPN];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostALPN = {
  "": "",
  h3: "h3",
  h2: "h2",
  "http/11": "http/1.1",
  "h3,h2,http/11": "h3,h2,http/1.1",
  "h3,h2": "h3,h2",
  "h2,http/11": "h2,http/1.1",
} as const;

export interface NotFound {
  detail?: string;
}

export type NodeUsageResponseNodeId = number | null;

export interface NodeUsageResponse {
  node_id?: NodeUsageResponseNodeId;
  node_name: string;
  uplink: number;
  downlink: number;
}

export interface NodesUsageResponse {
  usages: NodeUsageResponse[];
}

export type NodeStatus = (typeof NodeStatus)[keyof typeof NodeStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeStatus = {
  connected: "connected",
  connecting: "connecting",
  error: "error",
  disabled: "disabled",
} as const;

export interface NodeSettings {
  min_node_version?: string;
  certificate: string;
}

export type NodeResponseMessage = string | null;

export type NodeResponseXrayVersion = string | null;

export interface NodeResponse {
  name: string;
  address: string;
  port?: number;
  api_port?: number;
  /** */
  usage_coefficient?: number;
  id: number;
  xray_version?: NodeResponseXrayVersion;
  status: NodeStatus;
  message?: NodeResponseMessage;
}

/**
 * @nullable
 */
export type NodeModifyStatus = NodeStatus | null | null;

/**
 * @nullable
 */
export type NodeModifyUsageCoefficient = number | null | null;

/**
 * @nullable
 */
export type NodeModifyApiPort = number | null | null;

/**
 * @nullable
 */
export type NodeModifyPort = number | null | null;

/**
 * @nullable
 */
export type NodeModifyAddress = string | null | null;

/**
 * @nullable
 */
export type NodeModifyName = string | null | null;

export interface NodeModify {
  /** @nullable */
  name?: NodeModifyName;
  /** @nullable */
  address?: NodeModifyAddress;
  /** @nullable */
  port?: NodeModifyPort;
  /** @nullable */
  api_port?: NodeModifyApiPort;
  /** @nullable */
  usage_coefficient?: NodeModifyUsageCoefficient;
  /** @nullable */
  status?: NodeModifyStatus;
}

export interface NodeCreate {
  name: string;
  address: string;
  port?: number;
  api_port?: number;
  /** */
  usage_coefficient?: number;
}

export type NextPlanModelExpire = number | null;

export type NextPlanModelDataLimit = number | null;

export interface NextPlanModel {
  data_limit?: NextPlanModelDataLimit;
  expire?: NextPlanModelExpire;
  add_remaining_traffic?: boolean;
  fire_on_either?: boolean;
}

/**
 * @nullable
 */
export type HostResponseNoiseSetting = string | null | null;

export type HostResponseRandomUserAgent = boolean | null;

/**
 * @nullable
 */
export type HostResponseFragmentSetting = string | null | null;

export type HostResponseMuxEnable = boolean | null;

export type HostResponseIsDisabled = boolean | null;

export type HostResponseAllowinsecure = boolean | null;

/**
 * @nullable
 */
export type HostResponsePath = string | null | null;

/**
 * @nullable
 */
export type HostResponseHost = string | null | null;

/**
 * @nullable
 */
export type HostResponseSni = string | null | null;

/**
 * @nullable
 */
export type HostResponsePort = number | null | null;

export interface HostResponse {
  remark: string;
  address: string;
  inbound_tag: string;
  /** @nullable */
  port?: HostResponsePort;
  /** @nullable */
  sni?: HostResponseSni;
  /** @nullable */
  host?: HostResponseHost;
  /** @nullable */
  path?: HostResponsePath;
  security?: ProxyHostSecurity;
  alpn?: ProxyHostALPN;
  fingerprint?: ProxyHostFingerprint;
  allowinsecure?: HostResponseAllowinsecure;
  is_disabled?: HostResponseIsDisabled;
  mux_enable?: HostResponseMuxEnable;
  /** @nullable */
  fragment_setting?: HostResponseFragmentSetting;
  random_user_agent?: HostResponseRandomUserAgent;
  /** @nullable */
  noise_setting?: HostResponseNoiseSetting;
  id: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface HTTPException {
  detail: string;
}

export interface Forbidden {
  detail?: string;
}

/**
 * @nullable
 */
export type CreateHostNoiseSetting = string | null | null;

export type CreateHostRandomUserAgent = boolean | null;

/**
 * @nullable
 */
export type CreateHostFragmentSetting = string | null | null;

export type CreateHostMuxEnable = boolean | null;

export type CreateHostIsDisabled = boolean | null;

export type CreateHostAllowinsecure = boolean | null;

/**
 * @nullable
 */
export type CreateHostPath = string | null | null;

/**
 * @nullable
 */
export type CreateHostHost = string | null | null;

/**
 * @nullable
 */
export type CreateHostSni = string | null | null;

/**
 * @nullable
 */
export type CreateHostPort = number | null | null;

export interface CreateHost {
  remark: string;
  address: string;
  inbound_tag: string;
  /** @nullable */
  port?: CreateHostPort;
  /** @nullable */
  sni?: CreateHostSni;
  /** @nullable */
  host?: CreateHostHost;
  /** @nullable */
  path?: CreateHostPath;
  security?: ProxyHostSecurity;
  alpn?: ProxyHostALPN;
  fingerprint?: ProxyHostFingerprint;
  allowinsecure?: CreateHostAllowinsecure;
  is_disabled?: CreateHostIsDisabled;
  mux_enable?: CreateHostMuxEnable;
  /** @nullable */
  fragment_setting?: CreateHostFragmentSetting;
  random_user_agent?: CreateHostRandomUserAgent;
  /** @nullable */
  noise_setting?: CreateHostNoiseSetting;
}

export interface CoreStats {
  version: string;
  started: boolean;
  logs_websocket: string;
}

export interface Conflict {
  detail?: string;
}

export type BodyAdminTokenApiAdminTokenPostClientSecret = string | null;

export type BodyAdminTokenApiAdminTokenPostClientId = string | null;

export type BodyAdminTokenApiAdminTokenPostGrantType = string | null;

export interface BodyAdminTokenApiAdminTokenPost {
  grant_type?: BodyAdminTokenApiAdminTokenPostGrantType;
  username: string;
  password: string;
  scope?: string;
  client_id?: BodyAdminTokenApiAdminTokenPostClientId;
  client_secret?: BodyAdminTokenApiAdminTokenPostClientSecret;
}

export type AdminModifyDiscordWebhook = string | null;

export type AdminModifyTelegramId = number | null;

export type AdminModifyPassword = string | null;

export interface AdminModify {
  password?: AdminModifyPassword;
  is_sudo: boolean;
  telegram_id?: AdminModifyTelegramId;
  discord_webhook?: AdminModifyDiscordWebhook;
}

export type AdminCreateUsersUsage = number | null;

export type AdminCreateDiscordWebhook = string | null;

export type AdminCreateTelegramId = number | null;

export interface AdminCreate {
  username: string;
  is_sudo: boolean;
  telegram_id?: AdminCreateTelegramId;
  discord_webhook?: AdminCreateDiscordWebhook;
  users_usage?: AdminCreateUsersUsage;
  password: string;
}

export type AdminUsersUsage = number | null;

export type AdminDiscordWebhook = string | null;

export type AdminTelegramId = number | null;

export interface Admin {
  username: string;
  is_sudo: boolean;
  telegram_id?: AdminTelegramId;
  discord_webhook?: AdminDiscordWebhook;
  users_usage?: AdminUsersUsage;
}

/**
 * @summary Base
 */
export const base = (signal?: AbortSignal) => {
  return orvalFetcher<string>({ url: `/`, method: "GET", signal });
};

export const getBaseQueryKey = () => {
  return [`/`] as const;
};

export const getBaseQueryOptions = <
  TData = Awaited<ReturnType<typeof base>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBaseQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof base>>> = ({
    signal,
  }) => base(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof base>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BaseQueryResult = NonNullable<Awaited<ReturnType<typeof base>>>;
export type BaseQueryError = ErrorType<unknown>;

export function useBase<
  TData = Awaited<ReturnType<typeof base>>,
  TError = ErrorType<unknown>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof base>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBase<
  TData = Awaited<ReturnType<typeof base>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof base>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBase<
  TData = Awaited<ReturnType<typeof base>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Base
 */

export function useBase<
  TData = Awaited<ReturnType<typeof base>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBaseQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Authenticate an admin and issue a token.
 * @summary Admin Token
 */
export const adminToken = (
  bodyAdminTokenApiAdminTokenPost: BodyType<BodyAdminTokenApiAdminTokenPost>,
  signal?: AbortSignal
) => {
  const formUrlEncoded = new URLSearchParams();
  if (
    bodyAdminTokenApiAdminTokenPost.grant_type !== undefined &&
    bodyAdminTokenApiAdminTokenPost.grant_type !== null
  ) {
    formUrlEncoded.append(
      "grant_type",
      bodyAdminTokenApiAdminTokenPost.grant_type
    );
  }
  formUrlEncoded.append("username", bodyAdminTokenApiAdminTokenPost.username);
  formUrlEncoded.append("password", bodyAdminTokenApiAdminTokenPost.password);
  if (bodyAdminTokenApiAdminTokenPost.scope !== undefined) {
    formUrlEncoded.append("scope", bodyAdminTokenApiAdminTokenPost.scope);
  }
  if (
    bodyAdminTokenApiAdminTokenPost.client_id !== undefined &&
    bodyAdminTokenApiAdminTokenPost.client_id !== null
  ) {
    formUrlEncoded.append(
      "client_id",
      bodyAdminTokenApiAdminTokenPost.client_id
    );
  }
  if (
    bodyAdminTokenApiAdminTokenPost.client_secret !== undefined &&
    bodyAdminTokenApiAdminTokenPost.client_secret !== null
  ) {
    formUrlEncoded.append(
      "client_secret",
      bodyAdminTokenApiAdminTokenPost.client_secret
    );
  }

  return orvalFetcher<Token>({
    url: `/api/admin/token`,
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    data: formUrlEncoded,
    signal,
  });
};

export const getAdminTokenMutationOptions = <
  TData = Awaited<ReturnType<typeof adminToken>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
    TContext
  >;
}) => {
  const mutationKey = ["adminToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminToken>>,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> }
  > = (props) => {
    const { data } = props ?? {};

    return adminToken(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
    TContext
  >;
};

export type AdminTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminToken>>
>;
export type AdminTokenMutationBody = BodyType<BodyAdminTokenApiAdminTokenPost>;
export type AdminTokenMutationError = ErrorType<
  Unauthorized | HTTPValidationError
>;

/**
 * @summary Admin Token
 */
export const useAdminToken = <
  TData = Awaited<ReturnType<typeof adminToken>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
  TContext
> => {
  const mutationOptions = getAdminTokenMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve the current authenticated admin.
 * @summary Get Current Admin
 */
export const getCurrentAdmin = (signal?: AbortSignal) => {
  return orvalFetcher<Admin>({ url: `/api/admin`, method: "GET", signal });
};

export const getGetCurrentAdminQueryKey = () => {
  return [`/api/admin`] as const;
};

export const getGetCurrentAdminQueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentAdmin>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrentAdminQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAdmin>>> = ({
    signal,
  }) => getCurrentAdmin(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentAdmin>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCurrentAdminQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCurrentAdmin>>
>;
export type GetCurrentAdminQueryError = ErrorType<Unauthorized>;

export function useGetCurrentAdmin<
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<Unauthorized>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentAdmin>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCurrentAdmin>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrentAdmin<
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentAdmin>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCurrentAdmin>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrentAdmin<
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentAdmin>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Current Admin
 */

export function useGetCurrentAdmin<
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentAdmin>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCurrentAdminQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new admin if the current admin has sudo privileges.
 * @summary Create Admin
 */
export const createAdmin = (
  adminCreate: BodyType<AdminCreate>,
  signal?: AbortSignal
) => {
  return orvalFetcher<Admin>({
    url: `/api/admin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminCreate,
    signal,
  });
};

export const getCreateAdminMutationOptions = <
  TData = Awaited<ReturnType<typeof createAdmin>>,
  TError = ErrorType<Unauthorized | Forbidden | Conflict | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AdminCreate> },
    TContext
  >;
}) => {
  const mutationKey = ["createAdmin"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAdmin>>,
    { data: BodyType<AdminCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return createAdmin(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AdminCreate> },
    TContext
  >;
};

export type CreateAdminMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAdmin>>
>;
export type CreateAdminMutationBody = BodyType<AdminCreate>;
export type CreateAdminMutationError = ErrorType<
  Unauthorized | Forbidden | Conflict | HTTPValidationError
>;

/**
 * @summary Create Admin
 */
export const useCreateAdmin = <
  TData = Awaited<ReturnType<typeof createAdmin>>,
  TError = ErrorType<Unauthorized | Forbidden | Conflict | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<AdminCreate> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<AdminCreate> },
  TContext
> => {
  const mutationOptions = getCreateAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Modify an existing admin's details.
 * @summary Modify Admin
 */
export const modifyAdmin = (
  username: string,
  adminModify: BodyType<AdminModify>
) => {
  return orvalFetcher<Admin>({
    url: `/api/admin/${username}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminModify,
  });
};

export const getModifyAdminMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyAdmin>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { username: string; data: BodyType<AdminModify> },
    TContext
  >;
}) => {
  const mutationKey = ["modifyAdmin"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyAdmin>>,
    { username: string; data: BodyType<AdminModify> }
  > = (props) => {
    const { username, data } = props ?? {};

    return modifyAdmin(username, data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string; data: BodyType<AdminModify> },
    TContext
  >;
};

export type ModifyAdminMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyAdmin>>
>;
export type ModifyAdminMutationBody = BodyType<AdminModify>;
export type ModifyAdminMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Modify Admin
 */
export const useModifyAdmin = <
  TData = Awaited<ReturnType<typeof modifyAdmin>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { username: string; data: BodyType<AdminModify> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { username: string; data: BodyType<AdminModify> },
  TContext
> => {
  const mutationOptions = getModifyAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove an admin from the database.
 * @summary Remove Admin
 */
export const removeAdmin = (username: string) => {
  return orvalFetcher<unknown>({
    url: `/api/admin/${username}`,
    method: "DELETE",
  });
};

export const getRemoveAdminMutationOptions = <
  TData = Awaited<ReturnType<typeof removeAdmin>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}) => {
  const mutationKey = ["removeAdmin"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeAdmin>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return removeAdmin(username);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string },
    TContext
  >;
};

export type RemoveAdminMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeAdmin>>
>;

export type RemoveAdminMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Remove Admin
 */
export const useRemoveAdmin = <
  TData = Awaited<ReturnType<typeof removeAdmin>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}): UseMutationResult<TData, TError, { username: string }, TContext> => {
  const mutationOptions = getRemoveAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Fetch a list of admins with optional filters for pagination and username.
 * @summary Get Admins
 */
export const getAdmins = (params?: GetAdminsParams, signal?: AbortSignal) => {
  return orvalFetcher<Admin[]>({
    url: `/api/admins`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetAdminsQueryKey = (params?: GetAdminsParams) => {
  return [`/api/admins`, ...(params ? [params] : [])] as const;
};

export const getGetAdminsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetAdminsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdmins>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAdminsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmins>>> = ({
    signal,
  }) => getAdmins(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAdmins>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAdminsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAdmins>>
>;
export type GetAdminsQueryError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

export function useGetAdmins<
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params: undefined | GetAdminsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdmins>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmins>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAdmins<
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetAdminsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdmins>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmins>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAdmins<
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetAdminsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdmins>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Admins
 */

export function useGetAdmins<
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetAdminsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdmins>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAdminsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Disable all active users under a specific admin
 * @summary Disable All Active Users
 */
export const disableAllActiveUsers = (
  username: string,
  signal?: AbortSignal
) => {
  return orvalFetcher<unknown>({
    url: `/api/admin/${username}/users/disable`,
    method: "POST",
    signal,
  });
};

export const getDisableAllActiveUsersMutationOptions = <
  TData = Awaited<ReturnType<typeof disableAllActiveUsers>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}) => {
  const mutationKey = ["disableAllActiveUsers"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof disableAllActiveUsers>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return disableAllActiveUsers(username);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string },
    TContext
  >;
};

export type DisableAllActiveUsersMutationResult = NonNullable<
  Awaited<ReturnType<typeof disableAllActiveUsers>>
>;

export type DisableAllActiveUsersMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Disable All Active Users
 */
export const useDisableAllActiveUsers = <
  TData = Awaited<ReturnType<typeof disableAllActiveUsers>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}): UseMutationResult<TData, TError, { username: string }, TContext> => {
  const mutationOptions = getDisableAllActiveUsersMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Activate all disabled users under a specific admin
 * @summary Activate All Disabled Users
 */
export const activateAllDisabledUsers = (
  username: string,
  signal?: AbortSignal
) => {
  return orvalFetcher<unknown>({
    url: `/api/admin/${username}/users/activate`,
    method: "POST",
    signal,
  });
};

export const getActivateAllDisabledUsersMutationOptions = <
  TData = Awaited<ReturnType<typeof activateAllDisabledUsers>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}) => {
  const mutationKey = ["activateAllDisabledUsers"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateAllDisabledUsers>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return activateAllDisabledUsers(username);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string },
    TContext
  >;
};

export type ActivateAllDisabledUsersMutationResult = NonNullable<
  Awaited<ReturnType<typeof activateAllDisabledUsers>>
>;

export type ActivateAllDisabledUsersMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Activate All Disabled Users
 */
export const useActivateAllDisabledUsers = <
  TData = Awaited<ReturnType<typeof activateAllDisabledUsers>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}): UseMutationResult<TData, TError, { username: string }, TContext> => {
  const mutationOptions = getActivateAllDisabledUsersMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Resets usage of admin.
 * @summary Reset Admin Usage
 */
export const resetAdminUsage = (username: string, signal?: AbortSignal) => {
  return orvalFetcher<Admin>({
    url: `/api/admin/usage/reset/${username}`,
    method: "POST",
    signal,
  });
};

export const getResetAdminUsageMutationOptions = <
  TData = Awaited<ReturnType<typeof resetAdminUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}) => {
  const mutationKey = ["resetAdminUsage"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetAdminUsage>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return resetAdminUsage(username);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string },
    TContext
  >;
};

export type ResetAdminUsageMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetAdminUsage>>
>;

export type ResetAdminUsageMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Reset Admin Usage
 */
export const useResetAdminUsage = <
  TData = Awaited<ReturnType<typeof resetAdminUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}): UseMutationResult<TData, TError, { username: string }, TContext> => {
  const mutationOptions = getResetAdminUsageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve the usage of given admin.
 * @summary Get Admin Usage
 */
export const getAdminUsage = (username: string, signal?: AbortSignal) => {
  return orvalFetcher<number>({
    url: `/api/admin/usage/${username}`,
    method: "GET",
    signal,
  });
};

export const getGetAdminUsageQueryKey = (username: string) => {
  return [`/api/admin/usage/${username}`] as const;
};

export const getGetAdminUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdminUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdminUsage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAdminUsageQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminUsage>>> = ({
    signal,
  }) => getAdminUsage(username, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAdminUsage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAdminUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAdminUsage>>
>;
export type GetAdminUsageQueryError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

export function useGetAdminUsage<
  TData = Awaited<ReturnType<typeof getAdminUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  username: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdminUsage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAdminUsage<
  TData = Awaited<ReturnType<typeof getAdminUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdminUsage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAdminUsage<
  TData = Awaited<ReturnType<typeof getAdminUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdminUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Admin Usage
 */

export function useGetAdminUsage<
  TData = Awaited<ReturnType<typeof getAdminUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdminUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAdminUsageQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch system stats including memory, CPU, and user metrics.
 * @summary Get System Stats
 */
export const getSystemStats = (signal?: AbortSignal) => {
  return orvalFetcher<SystemStats>({
    url: `/api/system`,
    method: "GET",
    signal,
  });
};

export const getGetSystemStatsQueryKey = () => {
  return [`/api/system`] as const;
};

export const getGetSystemStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSystemStatsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemStats>>> = ({
    signal,
  }) => getSystemStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSystemStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSystemStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSystemStats>>
>;
export type GetSystemStatsQueryError = ErrorType<Unauthorized>;

export function useGetSystemStats<
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<Unauthorized>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getSystemStats>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSystemStats<
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getSystemStats>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSystemStats<
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get System Stats
 */

export function useGetSystemStats<
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSystemStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve inbound configurations grouped by protocol.
 * @summary Get Inbounds
 */
export const getInbounds = (signal?: AbortSignal) => {
  return orvalFetcher<GetInbounds200>({
    url: `/api/inbounds`,
    method: "GET",
    signal,
  });
};

export const getGetInboundsQueryKey = () => {
  return [`/api/inbounds`] as const;
};

export const getGetInboundsQueryOptions = <
  TData = Awaited<ReturnType<typeof getInbounds>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getInbounds>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInboundsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInbounds>>> = ({
    signal,
  }) => getInbounds(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInbounds>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInboundsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInbounds>>
>;
export type GetInboundsQueryError = ErrorType<Unauthorized>;

export function useGetInbounds<
  TData = Awaited<ReturnType<typeof getInbounds>>,
  TError = ErrorType<Unauthorized>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getInbounds>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getInbounds>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInbounds<
  TData = Awaited<ReturnType<typeof getInbounds>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getInbounds>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getInbounds>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInbounds<
  TData = Awaited<ReturnType<typeof getInbounds>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getInbounds>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Inbounds
 */

export function useGetInbounds<
  TData = Awaited<ReturnType<typeof getInbounds>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getInbounds>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetInboundsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve core statistics such as version and uptime.
 * @summary Get Core Stats
 */
export const getCoreStats = (signal?: AbortSignal) => {
  return orvalFetcher<CoreStats>({ url: `/api/core`, method: "GET", signal });
};

export const getGetCoreStatsQueryKey = () => {
  return [`/api/core`] as const;
};

export const getGetCoreStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreStats>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCoreStatsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoreStats>>> = ({
    signal,
  }) => getCoreStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCoreStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCoreStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCoreStats>>
>;
export type GetCoreStatsQueryError = ErrorType<Unauthorized>;

export function useGetCoreStats<
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<Unauthorized>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreStats>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCoreStats>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCoreStats<
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreStats>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCoreStats>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCoreStats<
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreStats>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Core Stats
 */

export function useGetCoreStats<
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<Unauthorized>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreStats>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCoreStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Restart the core and all connected nodes.
 * @summary Restart Core
 */
export const restartCore = (signal?: AbortSignal) => {
  return orvalFetcher<unknown>({
    url: `/api/core/restart`,
    method: "POST",
    signal,
  });
};

export const getRestartCoreMutationOptions = <
  TData = Awaited<ReturnType<typeof restartCore>>,
  TError = ErrorType<Unauthorized | Forbidden>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>;
}) => {
  const mutationKey = ["restartCore"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof restartCore>>,
    void
  > = () => {
    return restartCore();
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    void,
    TContext
  >;
};

export type RestartCoreMutationResult = NonNullable<
  Awaited<ReturnType<typeof restartCore>>
>;

export type RestartCoreMutationError = ErrorType<Unauthorized | Forbidden>;

/**
 * @summary Restart Core
 */
export const useRestartCore = <
  TData = Awaited<ReturnType<typeof restartCore>>,
  TError = ErrorType<Unauthorized | Forbidden>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>;
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getRestartCoreMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get the current core configuration.
 * @summary Get Core Config
 */
export const getCoreConfig = (signal?: AbortSignal) => {
  return orvalFetcher<GetCoreConfig200>({
    url: `/api/core/config`,
    method: "GET",
    signal,
  });
};

export const getGetCoreConfigQueryKey = () => {
  return [`/api/core/config`] as const;
};

export const getGetCoreConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreConfig>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCoreConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoreConfig>>> = ({
    signal,
  }) => getCoreConfig(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCoreConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCoreConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCoreConfig>>
>;
export type GetCoreConfigQueryError = ErrorType<Unauthorized | Forbidden>;

export function useGetCoreConfig<
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreConfig>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCoreConfig>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCoreConfig<
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreConfig>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getCoreConfig>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCoreConfig<
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreConfig>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Core Config
 */

export function useGetCoreConfig<
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCoreConfig>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCoreConfigQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Modify the core configuration and restart the core.
 * @summary Modify Core Config
 */
export const modifyCoreConfig = (
  modifyCoreConfigBody: BodyType<ModifyCoreConfigBody>
) => {
  return orvalFetcher<ModifyCoreConfig200>({
    url: `/api/core/config`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: modifyCoreConfigBody,
  });
};

export const getModifyCoreConfigMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyCoreConfig>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<ModifyCoreConfigBody> },
    TContext
  >;
}) => {
  const mutationKey = ["modifyCoreConfig"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyCoreConfig>>,
    { data: BodyType<ModifyCoreConfigBody> }
  > = (props) => {
    const { data } = props ?? {};

    return modifyCoreConfig(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<ModifyCoreConfigBody> },
    TContext
  >;
};

export type ModifyCoreConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyCoreConfig>>
>;
export type ModifyCoreConfigMutationBody = BodyType<ModifyCoreConfigBody>;
export type ModifyCoreConfigMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Modify Core Config
 */
export const useModifyCoreConfig = <
  TData = Awaited<ReturnType<typeof modifyCoreConfig>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<ModifyCoreConfigBody> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<ModifyCoreConfigBody> },
  TContext
> => {
  const mutationOptions = getModifyCoreConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * add a new host

**inbound_tag** must be available in one of xray config
 * @summary Add Host
 */
export const addHost = (
  createHost: BodyType<CreateHost>,
  signal?: AbortSignal
) => {
  return orvalFetcher<HostResponse>({
    url: `/api/host/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createHost,
    signal,
  });
};

export const getAddHostMutationOptions = <
  TData = Awaited<ReturnType<typeof addHost>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<CreateHost> },
    TContext
  >;
}) => {
  const mutationKey = ["addHost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addHost>>,
    { data: BodyType<CreateHost> }
  > = (props) => {
    const { data } = props ?? {};

    return addHost(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<CreateHost> },
    TContext
  >;
};

export type AddHostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addHost>>
>;
export type AddHostMutationBody = BodyType<CreateHost>;
export type AddHostMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Add Host
 */
export const useAddHost = <
  TData = Awaited<ReturnType<typeof addHost>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<CreateHost> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<CreateHost> },
  TContext
> => {
  const mutationOptions = getAddHostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * modify host by **id**

**inbound_tag** must be available in one of xray configs
 * @summary Modify Host
 */
export const modifyHost = (
  hostId: number,
  hostResponse: BodyType<HostResponse>
) => {
  return orvalFetcher<HostResponse>({
    url: `/api/host/${hostId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: hostResponse,
  });
};

export const getModifyHostMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyHost>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { hostId: number; data: BodyType<HostResponse> },
    TContext
  >;
}) => {
  const mutationKey = ["modifyHost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyHost>>,
    { hostId: number; data: BodyType<HostResponse> }
  > = (props) => {
    const { hostId, data } = props ?? {};

    return modifyHost(hostId, data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { hostId: number; data: BodyType<HostResponse> },
    TContext
  >;
};

export type ModifyHostMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyHost>>
>;
export type ModifyHostMutationBody = BodyType<HostResponse>;
export type ModifyHostMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Modify Host
 */
export const useModifyHost = <
  TData = Awaited<ReturnType<typeof modifyHost>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { hostId: number; data: BodyType<HostResponse> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { hostId: number; data: BodyType<HostResponse> },
  TContext
> => {
  const mutationOptions = getModifyHostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * remove host by **id**
 * @summary Remove Host
 */
export const removeHost = (hostId: number) => {
  return orvalFetcher<unknown>({
    url: `/api/host/${hostId}`,
    method: "DELETE",
  });
};

export const getRemoveHostMutationOptions = <
  TData = Awaited<ReturnType<typeof removeHost>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { hostId: number }, TContext>;
}) => {
  const mutationKey = ["removeHost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeHost>>,
    { hostId: number }
  > = (props) => {
    const { hostId } = props ?? {};

    return removeHost(hostId);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { hostId: number },
    TContext
  >;
};

export type RemoveHostMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeHost>>
>;

export type RemoveHostMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Remove Host
 */
export const useRemoveHost = <
  TData = Awaited<ReturnType<typeof removeHost>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { hostId: number }, TContext>;
}): UseMutationResult<TData, TError, { hostId: number }, TContext> => {
  const mutationOptions = getRemoveHostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * get host by **id**
 * @summary Get Host
 */
export const getHost = (hostId: number, signal?: AbortSignal) => {
  return orvalFetcher<HostResponse>({
    url: `/api/host/${hostId}`,
    method: "GET",
    signal,
  });
};

export const getGetHostQueryKey = (hostId: number) => {
  return [`/api/host/${hostId}`] as const;
};

export const getGetHostQueryOptions = <
  TData = Awaited<ReturnType<typeof getHost>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  hostId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHost>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHostQueryKey(hostId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHost>>> = ({
    signal,
  }) => getHost(hostId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!hostId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getHost>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetHostQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHost>>
>;
export type GetHostQueryError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

export function useGetHost<
  TData = Awaited<ReturnType<typeof getHost>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  hostId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHost>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHost>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetHost<
  TData = Awaited<ReturnType<typeof getHost>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  hostId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHost>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHost>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetHost<
  TData = Awaited<ReturnType<typeof getHost>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  hostId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHost>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Host
 */

export function useGetHost<
  TData = Awaited<ReturnType<typeof getHost>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  hostId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHost>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetHostQueryOptions(hostId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get proxy hosts.
 * @summary Get Hosts
 */
export const getHosts = (params?: GetHostsParams, signal?: AbortSignal) => {
  return orvalFetcher<HostResponse[]>({
    url: `/api/hosts`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetHostsQueryKey = (params?: GetHostsParams) => {
  return [`/api/hosts`, ...(params ? [params] : [])] as const;
};

export const getGetHostsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHosts>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetHostsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHostsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHosts>>> = ({
    signal,
  }) => getHosts(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHosts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetHostsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHosts>>
>;
export type GetHostsQueryError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

export function useGetHosts<
  TData = Awaited<ReturnType<typeof getHosts>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params: undefined | GetHostsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHosts>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetHosts<
  TData = Awaited<ReturnType<typeof getHosts>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetHostsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHosts>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetHosts<
  TData = Awaited<ReturnType<typeof getHosts>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetHostsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Hosts
 */

export function useGetHosts<
  TData = Awaited<ReturnType<typeof getHosts>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetHostsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetHostsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Modify proxy hosts and update the configuration.

if **host.id** doesn't exist, create new host
 * @summary Modify Hosts
 */
export const modifyHosts = (hostResponse: BodyType<HostResponse[]>) => {
  return orvalFetcher<HostResponse[]>({
    url: `/api/hosts`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: hostResponse,
  });
};

export const getModifyHostsMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyHosts>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<HostResponse[]> },
    TContext
  >;
}) => {
  const mutationKey = ["modifyHosts"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyHosts>>,
    { data: BodyType<HostResponse[]> }
  > = (props) => {
    const { data } = props ?? {};

    return modifyHosts(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<HostResponse[]> },
    TContext
  >;
};

export type ModifyHostsMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyHosts>>
>;
export type ModifyHostsMutationBody = BodyType<HostResponse[]>;
export type ModifyHostsMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Modify Hosts
 */
export const useModifyHosts = <
  TData = Awaited<ReturnType<typeof modifyHosts>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<HostResponse[]> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<HostResponse[]> },
  TContext
> => {
  const mutationOptions = getModifyHostsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve the current node settings, including TLS certificate.
 * @summary Get Node Settings
 */
export const getNodeSettings = (signal?: AbortSignal) => {
  return orvalFetcher<NodeSettings>({
    url: `/api/node/settings`,
    method: "GET",
    signal,
  });
};

export const getGetNodeSettingsQueryKey = () => {
  return [`/api/node/settings`] as const;
};

export const getGetNodeSettingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodeSettings>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeSettingsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeSettings>>> = ({
    signal,
  }) => getNodeSettings(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodeSettings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNodeSettingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeSettings>>
>;
export type GetNodeSettingsQueryError = ErrorType<Unauthorized | Forbidden>;

export function useGetNodeSettings<
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodeSettings>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNodeSettings>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNodeSettings<
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodeSettings>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNodeSettings>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNodeSettings<
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodeSettings>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Node Settings
 */

export function useGetNodeSettings<
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodeSettings>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNodeSettingsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Add a new node to the database and optionally add it as a host.
 * @summary Add Node
 */
export const addNode = (
  nodeCreate: BodyType<NodeCreate>,
  signal?: AbortSignal
) => {
  return orvalFetcher<NodeResponse>({
    url: `/api/node`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: nodeCreate,
    signal,
  });
};

export const getAddNodeMutationOptions = <
  TData = Awaited<ReturnType<typeof addNode>>,
  TError = ErrorType<Unauthorized | Forbidden | Conflict | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<NodeCreate> },
    TContext
  >;
}) => {
  const mutationKey = ["addNode"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addNode>>,
    { data: BodyType<NodeCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return addNode(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<NodeCreate> },
    TContext
  >;
};

export type AddNodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof addNode>>
>;
export type AddNodeMutationBody = BodyType<NodeCreate>;
export type AddNodeMutationError = ErrorType<
  Unauthorized | Forbidden | Conflict | HTTPValidationError
>;

/**
 * @summary Add Node
 */
export const useAddNode = <
  TData = Awaited<ReturnType<typeof addNode>>,
  TError = ErrorType<Unauthorized | Forbidden | Conflict | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<NodeCreate> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<NodeCreate> },
  TContext
> => {
  const mutationOptions = getAddNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve details of a specific node by its ID.
 * @summary Get Node
 */
export const getNode = (nodeId: number, signal?: AbortSignal) => {
  return orvalFetcher<NodeResponse>({
    url: `/api/node/${nodeId}`,
    method: "GET",
    signal,
  });
};

export const getGetNodeQueryKey = (nodeId: number) => {
  return [`/api/node/${nodeId}`] as const;
};

export const getGetNodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  nodeId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeQueryKey(nodeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNode>>> = ({
    signal,
  }) => getNode(nodeId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!nodeId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetNodeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNode>>
>;
export type GetNodeQueryError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

export function useGetNode<
  TData = Awaited<ReturnType<typeof getNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  nodeId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNode>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNode<
  TData = Awaited<ReturnType<typeof getNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  nodeId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNode>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNode<
  TData = Awaited<ReturnType<typeof getNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  nodeId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Node
 */

export function useGetNode<
  TData = Awaited<ReturnType<typeof getNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  nodeId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNodeQueryOptions(nodeId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update a node's details. Only accessible to sudo admins.
 * @summary Modify Node
 */
export const modifyNode = (
  nodeId: number,
  nodeModify: BodyType<NodeModify>
) => {
  return orvalFetcher<NodeResponse>({
    url: `/api/node/${nodeId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: nodeModify,
  });
};

export const getModifyNodeMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { nodeId: number; data: BodyType<NodeModify> },
    TContext
  >;
}) => {
  const mutationKey = ["modifyNode"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyNode>>,
    { nodeId: number; data: BodyType<NodeModify> }
  > = (props) => {
    const { nodeId, data } = props ?? {};

    return modifyNode(nodeId, data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { nodeId: number; data: BodyType<NodeModify> },
    TContext
  >;
};

export type ModifyNodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyNode>>
>;
export type ModifyNodeMutationBody = BodyType<NodeModify>;
export type ModifyNodeMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Modify Node
 */
export const useModifyNode = <
  TData = Awaited<ReturnType<typeof modifyNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { nodeId: number; data: BodyType<NodeModify> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { nodeId: number; data: BodyType<NodeModify> },
  TContext
> => {
  const mutationOptions = getModifyNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete a node and remove it from xray in the background.
 * @summary Remove Node
 */
export const removeNode = (nodeId: number) => {
  return orvalFetcher<unknown>({
    url: `/api/node/${nodeId}`,
    method: "DELETE",
  });
};

export const getRemoveNodeMutationOptions = <
  TData = Awaited<ReturnType<typeof removeNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { nodeId: number }, TContext>;
}) => {
  const mutationKey = ["removeNode"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeNode>>,
    { nodeId: number }
  > = (props) => {
    const { nodeId } = props ?? {};

    return removeNode(nodeId);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { nodeId: number },
    TContext
  >;
};

export type RemoveNodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeNode>>
>;

export type RemoveNodeMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Remove Node
 */
export const useRemoveNode = <
  TData = Awaited<ReturnType<typeof removeNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { nodeId: number }, TContext>;
}): UseMutationResult<TData, TError, { nodeId: number }, TContext> => {
  const mutationOptions = getRemoveNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve a list of all nodes. Accessible only to sudo admins.
 * @summary Get Nodes
 */
export const getNodes = (signal?: AbortSignal) => {
  return orvalFetcher<NodeResponse[]>({
    url: `/api/nodes`,
    method: "GET",
    signal,
  });
};

export const getGetNodesQueryKey = () => {
  return [`/api/nodes`] as const;
};

export const getGetNodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodes>>> = ({
    signal,
  }) => getNodes(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodes>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNodesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodes>>
>;
export type GetNodesQueryError = ErrorType<Unauthorized | Forbidden>;

export function useGetNodes<
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNodes>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNodes<
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof getNodes>>,
        TError,
        TData
      >,
      "initialData"
    >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNodes<
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Nodes
 */

export function useGetNodes<
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<Unauthorized | Forbidden>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>
  >;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNodesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Trigger a reconnection for the specified node. Only accessible to sudo admins.
 * @summary Reconnect Node
 */
export const reconnectNode = (nodeId: number, signal?: AbortSignal) => {
  return orvalFetcher<unknown>({
    url: `/api/node/${nodeId}/reconnect`,
    method: "POST",
    signal,
  });
};

export const getReconnectNodeMutationOptions = <
  TData = Awaited<ReturnType<typeof reconnectNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { nodeId: number }, TContext>;
}) => {
  const mutationKey = ["reconnectNode"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reconnectNode>>,
    { nodeId: number }
  > = (props) => {
    const { nodeId } = props ?? {};

    return reconnectNode(nodeId);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { nodeId: number },
    TContext
  >;
};

export type ReconnectNodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof reconnectNode>>
>;

export type ReconnectNodeMutationError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

/**
 * @summary Reconnect Node
 */
export const useReconnectNode = <
  TData = Awaited<ReturnType<typeof reconnectNode>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { nodeId: number }, TContext>;
}): UseMutationResult<TData, TError, { nodeId: number }, TContext> => {
  const mutationOptions = getReconnectNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Retrieve usage statistics for nodes within a specified date range.
 * @summary Get Usage
 */
export const getUsage = (params?: GetUsageParams, signal?: AbortSignal) => {
  return orvalFetcher<NodesUsageResponse>({
    url: `/api/nodes/usage`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetUsageQueryKey = (params?: GetUsageParams) => {
  return [`/api/nodes/usage`, ...(params ? [params] : [])] as const;
};

export const getGetUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsageQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsage>>> = ({
    signal,
  }) => getUsage(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsage>>
>;
export type GetUsageQueryError = ErrorType<
  Unauthorized | Forbidden | HTTPValidationError
>;

export function useGetUsage<
  TData = Awaited<ReturnType<typeof getUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params: undefined | GetUsageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsage<
  TData = Awaited<ReturnType<typeof getUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsage<
  TData = Awaited<ReturnType<typeof getUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Usage
 */

export function useGetUsage<
  TData = Awaited<ReturnType<typeof getUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | HTTPValidationError>
>(
  params?: GetUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUsageQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Add a new user

- **username**: 3 to 32 characters, can include a-z, 0-9, and underscores.
- **status**: User's status, defaults to `active`. Special rules if `on_hold`.
- **expire**: UTC datetime for account expiration. Use `0` for unlimited.
- **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited.
- **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets.
- **proxies**: Dictionary of protocol settings (e.g., `vmess`, `vless`).
- **inbounds**: Dictionary of protocol tags to specify inbound connections.
- **note**: Optional text field for additional user information or notes.
- **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end.
- **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status.
- **next_plan**: Next user plan (resets after use).
 * @summary Add User
 */
export const addUser = (
  userCreate: BodyType<UserCreate>,
  signal?: AbortSignal
) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userCreate,
    signal,
  });
};

export const getAddUserMutationOptions = <
  TData = Awaited<ReturnType<typeof addUser>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Conflict | HTTPValidationError
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<UserCreate> },
    TContext
  >;
}) => {
  const mutationKey = ["addUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addUser>>,
    { data: BodyType<UserCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return addUser(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<UserCreate> },
    TContext
  >;
};

export type AddUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof addUser>>
>;
export type AddUserMutationBody = BodyType<UserCreate>;
export type AddUserMutationError = ErrorType<
  HTTPException | Unauthorized | Conflict | HTTPValidationError
>;

/**
 * @summary Add User
 */
export const useAddUser = <
  TData = Awaited<ReturnType<typeof addUser>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Conflict | HTTPValidationError
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<UserCreate> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<UserCreate> },
  TContext
> => {
  const mutationOptions = getAddUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get user information
 * @summary Get User
 */
export const getUser = (username: string, signal?: AbortSignal) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}`,
    method: "GET",
    signal,
  });
};

export const getGetUserQueryKey = (username: string) => {
  return [`/api/user/${username}`] as const;
};

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(username, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>;
export type GetUserQueryError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get User
 */

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Modify an existing user

- **username**: Cannot be changed. Used to identify the user.
- **status**: User's new status. Can be 'active', 'disabled', 'on_hold', 'limited', or 'expired'.
- **expire**: UTC datetime for new account expiration. Set to `0` for unlimited, `null` for no change.
- **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change.
- **data_limit_reset_strategy**: New strategy for data limit reset. Options include 'daily', 'weekly', 'monthly', or 'no_reset'.
- **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change.
- **inbounds**: Dictionary of new protocol tags to specify inbound connections. Empty dictionary means no change.
- **note**: New optional text for additional user information or notes. `null` means no change.
- **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to 'on_hold'.
- **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to 'on_hold'.
- **next_plan**: Next user plan (resets after use).

Note: Fields set to `null` or omitted will not be modified.
 * @summary Modify User
 */
export const modifyUser = (
  username: string,
  userModify: BodyType<UserModify>
) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userModify,
  });
};

export const getModifyUserMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyUser>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { username: string; data: BodyType<UserModify> },
    TContext
  >;
}) => {
  const mutationKey = ["modifyUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyUser>>,
    { username: string; data: BodyType<UserModify> }
  > = (props) => {
    const { username, data } = props ?? {};

    return modifyUser(username, data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string; data: BodyType<UserModify> },
    TContext
  >;
};

export type ModifyUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyUser>>
>;
export type ModifyUserMutationBody = BodyType<UserModify>;
export type ModifyUserMutationError = ErrorType<
  HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Modify User
 */
export const useModifyUser = <
  TData = Awaited<ReturnType<typeof modifyUser>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { username: string; data: BodyType<UserModify> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { username: string; data: BodyType<UserModify> },
  TContext
> => {
  const mutationOptions = getModifyUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove a user
 * @summary Remove User
 */
export const removeUser = (username: string) => {
  return orvalFetcher<unknown>({
    url: `/api/user/${username}`,
    method: "DELETE",
  });
};

export const getRemoveUserMutationOptions = <
  TData = Awaited<ReturnType<typeof removeUser>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}) => {
  const mutationKey = ["removeUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUser>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return removeUser(username);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string },
    TContext
  >;
};

export type RemoveUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUser>>
>;

export type RemoveUserMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Remove User
 */
export const useRemoveUser = <
  TData = Awaited<ReturnType<typeof removeUser>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}): UseMutationResult<TData, TError, { username: string }, TContext> => {
  const mutationOptions = getRemoveUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reset user data usage
 * @summary Reset User Data Usage
 */
export const resetUserDataUsage = (username: string, signal?: AbortSignal) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}/reset`,
    method: "POST",
    signal,
  });
};

export const getResetUserDataUsageMutationOptions = <
  TData = Awaited<ReturnType<typeof resetUserDataUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}) => {
  const mutationKey = ["resetUserDataUsage"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetUserDataUsage>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return resetUserDataUsage(username);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string },
    TContext
  >;
};

export type ResetUserDataUsageMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetUserDataUsage>>
>;

export type ResetUserDataUsageMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Reset User Data Usage
 */
export const useResetUserDataUsage = <
  TData = Awaited<ReturnType<typeof resetUserDataUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}): UseMutationResult<TData, TError, { username: string }, TContext> => {
  const mutationOptions = getResetUserDataUsageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Revoke users subscription (Subscription link and proxies)
 * @summary Revoke User Subscription
 */
export const revokeUserSubscription = (
  username: string,
  signal?: AbortSignal
) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}/revoke_sub`,
    method: "POST",
    signal,
  });
};

export const getRevokeUserSubscriptionMutationOptions = <
  TData = Awaited<ReturnType<typeof revokeUserSubscription>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}) => {
  const mutationKey = ["revokeUserSubscription"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revokeUserSubscription>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return revokeUserSubscription(username);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string },
    TContext
  >;
};

export type RevokeUserSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof revokeUserSubscription>>
>;

export type RevokeUserSubscriptionMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Revoke User Subscription
 */
export const useRevokeUserSubscription = <
  TData = Awaited<ReturnType<typeof revokeUserSubscription>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}): UseMutationResult<TData, TError, { username: string }, TContext> => {
  const mutationOptions = getRevokeUserSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get all users
 * @summary Get Users
 */
export const getUsers = (params?: GetUsersParams, signal?: AbortSignal) => {
  return orvalFetcher<UsersResponse>({
    url: `/api/users`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetUsersQueryKey = (params?: GetUsersParams) => {
  return [`/api/users`, ...(params ? [params] : [])] as const;
};

export const getGetUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
  >
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({
    signal,
  }) => getUsers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsers>>
>;
export type GetUsersQueryError = ErrorType<
  HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

export function useGetUsers<
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
  >
>(
  params: undefined | GetUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsers<
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
  >
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsers<
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
  >
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Users
 */

export function useGetUsers<
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<
    HTTPException | Unauthorized | Forbidden | NotFound | HTTPValidationError
  >
>(
  params?: GetUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUsersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Reset all users data usage
 * @summary Reset Users Data Usage
 */
export const resetUsersDataUsage = (signal?: AbortSignal) => {
  return orvalFetcher<unknown>({
    url: `/api/users/reset`,
    method: "POST",
    signal,
  });
};

export const getResetUsersDataUsageMutationOptions = <
  TData = Awaited<ReturnType<typeof resetUsersDataUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>;
}) => {
  const mutationKey = ["resetUsersDataUsage"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetUsersDataUsage>>,
    void
  > = () => {
    return resetUsersDataUsage();
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    void,
    TContext
  >;
};

export type ResetUsersDataUsageMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetUsersDataUsage>>
>;

export type ResetUsersDataUsageMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound
>;

/**
 * @summary Reset Users Data Usage
 */
export const useResetUsersDataUsage = <
  TData = Awaited<ReturnType<typeof resetUsersDataUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, void, TContext>;
}): UseMutationResult<TData, TError, void, TContext> => {
  const mutationOptions = getResetUsersDataUsageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get users usage
 * @summary Get User Usage
 */
export const getUserUsage = (
  username: string,
  params?: GetUserUsageParams,
  signal?: AbortSignal
) => {
  return orvalFetcher<UserUsagesResponse>({
    url: `/api/user/${username}/usage`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetUserUsageQueryKey = (
  username: string,
  params?: GetUserUsageParams
) => {
  return [`/api/user/${username}/usage`, ...(params ? [params] : [])] as const;
};

export const getGetUserUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  params?: GetUserUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserUsage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserUsageQueryKey(username, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserUsage>>> = ({
    signal,
  }) => getUserUsage(username, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserUsage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserUsage>>
>;
export type GetUserUsageQueryError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

export function useGetUserUsage<
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  params: undefined | GetUserUsageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserUsage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserUsage<
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  params?: GetUserUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserUsage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserUsage<
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  params?: GetUserUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get User Usage
 */

export function useGetUserUsage<
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>
>(
  username: string,
  params?: GetUserUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserUsageQueryOptions(username, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Reset user by next plan
 * @summary Active Next Plan
 */
export const activeNextPlan = (username: string, signal?: AbortSignal) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}/active-next`,
    method: "POST",
    signal,
  });
};

export const getActiveNextPlanMutationOptions = <
  TData = Awaited<ReturnType<typeof activeNextPlan>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}) => {
  const mutationKey = ["activeNextPlan"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activeNextPlan>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return activeNextPlan(username);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string },
    TContext
  >;
};

export type ActiveNextPlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof activeNextPlan>>
>;

export type ActiveNextPlanMutationError = ErrorType<
  Unauthorized | Forbidden | NotFound | HTTPValidationError
>;

/**
 * @summary Active Next Plan
 */
export const useActiveNextPlan = <
  TData = Awaited<ReturnType<typeof activeNextPlan>>,
  TError = ErrorType<Unauthorized | Forbidden | NotFound | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { username: string }, TContext>;
}): UseMutationResult<TData, TError, { username: string }, TContext> => {
  const mutationOptions = getActiveNextPlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get all users usage
 * @summary Get Users Usage
 */
export const getUsersUsage = (
  params?: GetUsersUsageParams,
  signal?: AbortSignal
) => {
  return orvalFetcher<UsersUsagesResponse>({
    url: `/api/users/usage`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetUsersUsageQueryKey = (params?: GetUsersUsageParams) => {
  return [`/api/users/usage`, ...(params ? [params] : [])] as const;
};

export const getGetUsersUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsersUsage>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params?: GetUsersUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersUsage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersUsageQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersUsage>>> = ({
    signal,
  }) => getUsersUsage(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsersUsage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsersUsage>>
>;
export type GetUsersUsageQueryError = ErrorType<
  Unauthorized | HTTPValidationError
>;

export function useGetUsersUsage<
  TData = Awaited<ReturnType<typeof getUsersUsage>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params: undefined | GetUsersUsageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersUsage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersUsage<
  TData = Awaited<ReturnType<typeof getUsersUsage>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params?: GetUsersUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersUsage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersUsage<
  TData = Awaited<ReturnType<typeof getUsersUsage>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params?: GetUsersUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Users Usage
 */

export function useGetUsersUsage<
  TData = Awaited<ReturnType<typeof getUsersUsage>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params?: GetUsersUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUsersUsageQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Set a new owner (admin) for a user.
 * @summary Set Owner
 */
export const setOwner = (username: string, params: SetOwnerParams) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}/set-owner`,
    method: "PUT",
    params,
  });
};

export const getSetOwnerMutationOptions = <
  TData = Awaited<ReturnType<typeof setOwner>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { username: string; params: SetOwnerParams },
    TContext
  >;
}) => {
  const mutationKey = ["setOwner"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setOwner>>,
    { username: string; params: SetOwnerParams }
  > = (props) => {
    const { username, params } = props ?? {};

    return setOwner(username, params);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { username: string; params: SetOwnerParams },
    TContext
  >;
};

export type SetOwnerMutationResult = NonNullable<
  Awaited<ReturnType<typeof setOwner>>
>;

export type SetOwnerMutationError = ErrorType<
  Unauthorized | HTTPValidationError
>;

/**
 * @summary Set Owner
 */
export const useSetOwner = <
  TData = Awaited<ReturnType<typeof setOwner>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { username: string; params: SetOwnerParams },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { username: string; params: SetOwnerParams },
  TContext
> => {
  const mutationOptions = getSetOwnerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get users who have expired within the specified date range.

- **expired_after** UTC datetime (optional)
- **expired_before** UTC datetime (optional)
- At least one of expired_after or expired_before must be provided for filtering
- If both are omitted, returns all expired users
 * @summary Get Expired Users
 */
export const getExpiredUsers = (
  params?: GetExpiredUsersParams,
  signal?: AbortSignal
) => {
  return orvalFetcher<string[]>({
    url: `/api/users/expired`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetExpiredUsersQueryKey = (params?: GetExpiredUsersParams) => {
  return [`/api/users/expired`, ...(params ? [params] : [])] as const;
};

export const getGetExpiredUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getExpiredUsers>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params?: GetExpiredUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpiredUsers>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExpiredUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpiredUsers>>> = ({
    signal,
  }) => getExpiredUsers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExpiredUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExpiredUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExpiredUsers>>
>;
export type GetExpiredUsersQueryError = ErrorType<
  Unauthorized | HTTPValidationError
>;

export function useGetExpiredUsers<
  TData = Awaited<ReturnType<typeof getExpiredUsers>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params: undefined | GetExpiredUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpiredUsers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpiredUsers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExpiredUsers<
  TData = Awaited<ReturnType<typeof getExpiredUsers>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params?: GetExpiredUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpiredUsers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpiredUsers>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExpiredUsers<
  TData = Awaited<ReturnType<typeof getExpiredUsers>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params?: GetExpiredUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpiredUsers>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Expired Users
 */

export function useGetExpiredUsers<
  TData = Awaited<ReturnType<typeof getExpiredUsers>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>
>(
  params?: GetExpiredUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpiredUsers>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExpiredUsersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete users who have expired within the specified date range.

- **expired_after** UTC datetime (optional)
- **expired_before** UTC datetime (optional)
- At least one of expired_after or expired_before must be provided
 * @summary Delete Expired Users
 */
export const deleteExpiredUsers = (params?: DeleteExpiredUsersParams) => {
  return orvalFetcher<string[]>({
    url: `/api/users/expired`,
    method: "DELETE",
    params,
  });
};

export const getDeleteExpiredUsersMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteExpiredUsers>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { params?: DeleteExpiredUsersParams },
    TContext
  >;
}) => {
  const mutationKey = ["deleteExpiredUsers"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteExpiredUsers>>,
    { params?: DeleteExpiredUsersParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteExpiredUsers(params);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { params?: DeleteExpiredUsersParams },
    TContext
  >;
};

export type DeleteExpiredUsersMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteExpiredUsers>>
>;

export type DeleteExpiredUsersMutationError = ErrorType<
  Unauthorized | HTTPValidationError
>;

/**
 * @summary Delete Expired Users
 */
export const useDeleteExpiredUsers = <
  TData = Awaited<ReturnType<typeof deleteExpiredUsers>>,
  TError = ErrorType<Unauthorized | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { params?: DeleteExpiredUsersParams },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { params?: DeleteExpiredUsersParams },
  TContext
> => {
  const mutationOptions = getDeleteExpiredUsersMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Provides a subscription link based on the user agent (Clash, V2Ray, etc.).
 * @summary User Subscription
 */
export const userSubscription = (token: string, signal?: AbortSignal) => {
  return orvalFetcher<unknown>({
    url: `/sub/${token}/`,
    method: "GET",
    signal,
  });
};

export const getUserSubscriptionQueryKey = (token: string) => {
  return [`/sub/${token}/`] as const;
};

export const getUserSubscriptionQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscription>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserSubscriptionQueryKey(token);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userSubscription>>
  > = ({ signal }) => userSubscription(token, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!token,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscription>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserSubscriptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof userSubscription>>
>;
export type UserSubscriptionQueryError = ErrorType<HTTPValidationError>;

export function useUserSubscription<
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userSubscription>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserSubscription<
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userSubscription>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserSubscription<
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscription>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary User Subscription
 */

export function useUserSubscription<
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscription>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserSubscriptionQueryOptions(token, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves detailed information about the user's subscription.
 * @summary User Subscription Info
 */
export const userSubscriptionInfo = (token: string, signal?: AbortSignal) => {
  return orvalFetcher<SubscriptionUserResponse>({
    url: `/sub/${token}/info`,
    method: "GET",
    signal,
  });
};

export const getUserSubscriptionInfoQueryKey = (token: string) => {
  return [`/sub/${token}/info`] as const;
};

export const getUserSubscriptionInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionInfo>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserSubscriptionInfoQueryKey(token);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userSubscriptionInfo>>
  > = ({ signal }) => userSubscriptionInfo(token, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!token,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscriptionInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserSubscriptionInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof userSubscriptionInfo>>
>;
export type UserSubscriptionInfoQueryError = ErrorType<HTTPValidationError>;

export function useUserSubscriptionInfo<
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userSubscriptionInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserSubscriptionInfo<
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionInfo>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userSubscriptionInfo>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserSubscriptionInfo<
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionInfo>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary User Subscription Info
 */

export function useUserSubscriptionInfo<
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionInfo>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserSubscriptionInfoQueryOptions(token, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetches the usage statistics for the user within a specified date range.
 * @summary User Get Usage
 */
export const userGetUsage = (
  token: string,
  params?: UserGetUsageParams,
  signal?: AbortSignal
) => {
  return orvalFetcher<unknown>({
    url: `/sub/${token}/usage`,
    method: "GET",
    params,
    signal,
  });
};

export const getUserGetUsageQueryKey = (
  token: string,
  params?: UserGetUsageParams
) => {
  return [`/sub/${token}/usage`, ...(params ? [params] : [])] as const;
};

export const getUserGetUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params?: UserGetUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userGetUsage>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserGetUsageQueryKey(token, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetUsage>>> = ({
    signal,
  }) => userGetUsage(token, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!token,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userGetUsage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserGetUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof userGetUsage>>
>;
export type UserGetUsageQueryError = ErrorType<HTTPValidationError>;

export function useUserGetUsage<
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params: undefined | UserGetUsageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userGetUsage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userGetUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserGetUsage<
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params?: UserGetUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userGetUsage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userGetUsage>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserGetUsage<
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params?: UserGetUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userGetUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary User Get Usage
 */

export function useUserGetUsage<
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params?: UserGetUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userGetUsage>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserGetUsageQueryOptions(token, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Provides a subscription link based on the specified client type (e.g., Clash, V2Ray).
 * @summary User Subscription With Client Type
 */
export const userSubscriptionWithClientType = (
  token: string,
  clientType: string,
  signal?: AbortSignal
) => {
  return orvalFetcher<unknown>({
    url: `/sub/${token}/${clientType}`,
    method: "GET",
    signal,
  });
};

export const getUserSubscriptionWithClientTypeQueryKey = (
  token: string,
  clientType: string
) => {
  return [`/sub/${token}/${clientType}`] as const;
};

export const getUserSubscriptionWithClientTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  clientType: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getUserSubscriptionWithClientTypeQueryKey(token, clientType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userSubscriptionWithClientType>>
  > = ({ signal }) => userSubscriptionWithClientType(token, clientType, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(token && clientType),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserSubscriptionWithClientTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof userSubscriptionWithClientType>>
>;
export type UserSubscriptionWithClientTypeQueryError =
  ErrorType<HTTPValidationError>;

export function useUserSubscriptionWithClientType<
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  clientType: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserSubscriptionWithClientType<
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  clientType: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserSubscriptionWithClientType<
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  clientType: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary User Subscription With Client Type
 */

export function useUserSubscriptionWithClientType<
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  clientType: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserSubscriptionWithClientTypeQueryOptions(
    token,
    clientType,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Add a new user template

- **name** can be up to 64 characters
- **data_limit** must be in bytes and larger or equal to 0
- **expire_duration** must be in seconds and larger or equat to 0
- **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
 * @summary Add User Template
 */
export const addUserTemplate = (
  userTemplateCreate: BodyType<UserTemplateCreate>,
  signal?: AbortSignal
) => {
  return orvalFetcher<UserTemplateResponse>({
    url: `/api/user_template`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userTemplateCreate,
    signal,
  });
};

export const getAddUserTemplateMutationOptions = <
  TData = Awaited<ReturnType<typeof addUserTemplate>>,
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<UserTemplateCreate> },
    TContext
  >;
}) => {
  const mutationKey = ["addUserTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addUserTemplate>>,
    { data: BodyType<UserTemplateCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return addUserTemplate(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: BodyType<UserTemplateCreate> },
    TContext
  >;
};

export type AddUserTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof addUserTemplate>>
>;
export type AddUserTemplateMutationBody = BodyType<UserTemplateCreate>;
export type AddUserTemplateMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Add User Template
 */
export const useAddUserTemplate = <
  TData = Awaited<ReturnType<typeof addUserTemplate>>,
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: BodyType<UserTemplateCreate> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: BodyType<UserTemplateCreate> },
  TContext
> => {
  const mutationOptions = getAddUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get a list of User Templates with optional pagination
 * @summary Get User Templates
 */
export const getUserTemplates = (
  params?: GetUserTemplatesParams,
  signal?: AbortSignal
) => {
  return orvalFetcher<UserTemplateResponse[]>({
    url: `/api/user_template`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetUserTemplatesQueryKey = (
  params?: GetUserTemplatesParams
) => {
  return [`/api/user_template`, ...(params ? [params] : [])] as const;
};

export const getGetUserTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUserTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplates>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserTemplatesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserTemplates>>
  > = ({ signal }) => getUserTemplates(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserTemplates>>
>;
export type GetUserTemplatesQueryError = ErrorType<HTTPValidationError>;

export function useGetUserTemplates<
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params: undefined | GetUserTemplatesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTemplates>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTemplates<
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUserTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTemplates>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTemplates<
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUserTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplates>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get User Templates
 */

export function useGetUserTemplates<
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUserTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplates>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserTemplatesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get User Template information with id
 * @summary Get User Template Endpoint
 */
export const getUserTemplateEndpoint = (
  templateId: number,
  signal?: AbortSignal
) => {
  return orvalFetcher<UserTemplateResponse>({
    url: `/api/user_template/${templateId}`,
    method: "GET",
    signal,
  });
};

export const getGetUserTemplateEndpointQueryKey = (templateId: number) => {
  return [`/api/user_template/${templateId}`] as const;
};

export const getGetUserTemplateEndpointQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
  TError = ErrorType<HTTPValidationError>
>(
  templateId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserTemplateEndpointQueryKey(templateId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserTemplateEndpoint>>
  > = ({ signal }) => getUserTemplateEndpoint(templateId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserTemplateEndpointQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserTemplateEndpoint>>
>;
export type GetUserTemplateEndpointQueryError = ErrorType<HTTPValidationError>;

export function useGetUserTemplateEndpoint<
  TData = Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
  TError = ErrorType<HTTPValidationError>
>(
  templateId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTemplateEndpoint<
  TData = Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
  TError = ErrorType<HTTPValidationError>
>(
  templateId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
          TError,
          TData
        >,
        "initialData"
      >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTemplateEndpoint<
  TData = Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
  TError = ErrorType<HTTPValidationError>
>(
  templateId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get User Template Endpoint
 */

export function useGetUserTemplateEndpoint<
  TData = Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
  TError = ErrorType<HTTPValidationError>
>(
  templateId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTemplateEndpoint>>,
        TError,
        TData
      >
    >;
  }
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserTemplateEndpointQueryOptions(
    templateId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Modify User Template

- **name** can be up to 64 characters
- **data_limit** must be in bytes and larger or equal to 0
- **expire_duration** must be in seconds and larger or equat to 0
- **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
 * @summary Modify User Template
 */
export const modifyUserTemplate = (
  templateId: number,
  userTemplateModify: BodyType<UserTemplateModify>
) => {
  return orvalFetcher<UserTemplateResponse>({
    url: `/api/user_template/${templateId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userTemplateModify,
  });
};

export const getModifyUserTemplateMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyUserTemplate>>,
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { templateId: number; data: BodyType<UserTemplateModify> },
    TContext
  >;
}) => {
  const mutationKey = ["modifyUserTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyUserTemplate>>,
    { templateId: number; data: BodyType<UserTemplateModify> }
  > = (props) => {
    const { templateId, data } = props ?? {};

    return modifyUserTemplate(templateId, data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { templateId: number; data: BodyType<UserTemplateModify> },
    TContext
  >;
};

export type ModifyUserTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyUserTemplate>>
>;
export type ModifyUserTemplateMutationBody = BodyType<UserTemplateModify>;
export type ModifyUserTemplateMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Modify User Template
 */
export const useModifyUserTemplate = <
  TData = Awaited<ReturnType<typeof modifyUserTemplate>>,
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { templateId: number; data: BodyType<UserTemplateModify> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { templateId: number; data: BodyType<UserTemplateModify> },
  TContext
> => {
  const mutationOptions = getModifyUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove a User Template by its ID
 * @summary Remove User Template
 */
export const removeUserTemplate = (templateId: number) => {
  return orvalFetcher<unknown>({
    url: `/api/user_template/${templateId}`,
    method: "DELETE",
  });
};

export const getRemoveUserTemplateMutationOptions = <
  TData = Awaited<ReturnType<typeof removeUserTemplate>>,
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { templateId: number },
    TContext
  >;
}) => {
  const mutationKey = ["removeUserTemplate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUserTemplate>>,
    { templateId: number }
  > = (props) => {
    const { templateId } = props ?? {};

    return removeUserTemplate(templateId);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { templateId: number },
    TContext
  >;
};

export type RemoveUserTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUserTemplate>>
>;

export type RemoveUserTemplateMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Remove User Template
 */
export const useRemoveUserTemplate = <
  TData = Awaited<ReturnType<typeof removeUserTemplate>>,
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { templateId: number },
    TContext
  >;
}): UseMutationResult<TData, TError, { templateId: number }, TContext> => {
  const mutationOptions = getRemoveUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};
