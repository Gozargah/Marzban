/**
 * Generated by orval v6.23.0 üç∫
 * Do not edit manually.
 * MarzbanAPI
 * Unified GUI Censorship Resistant Solution Powered by Xray
 * OpenAPI spec version: 0.4.1
 */
import { useMutation, useQuery } from "react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from "react-query";
import { orvalFetcher } from "../http";
import type { ErrorType, BodyType } from "../http";
export type GetNodesUsageParams = {
  start?: string;
  end?: string;
};

export type GetUserTemplatesParams = {
  offset?: number;
  limit?: number;
};

export type DeleteExpiredParams = {
  passed_time: number;
};

export type SetOwnerParams = {
  admin_username: string;
};

export type GetUserUsageParams = {
  start?: string;
  end?: string;
};

export type GetUsersParams = {
  offset?: number;
  limit?: number;
  username?: string[];
  status?: UserStatus;
  sort?: string;
};

export type ModifyCoreConfig200 = { [key: string]: any };

export type ModifyCoreConfigBody = { [key: string]: any };

export type GetCoreConfig200 = { [key: string]: any };

export type ModifyHosts200 = { [key: string]: ProxyHost[] };

export type ModifyHostsBody = { [key: string]: ProxyHost[] };

export type GetHosts200 = { [key: string]: ProxyHost[] };

export type GetInbounds200 = { [key: string]: ProxyInbound[] };

export type UserGetUsageParams = {
  start?: string;
  end?: string;
};

export type GetAdminsParams = {
  offset?: number;
  limit?: number;
  username?: string;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface UsersResponse {
  total: number;
  users: UserResponse[];
}

export interface UserUsageResponse {
  node_id?: number;
  node_name: string;
  used_traffic: number;
}

export interface UserUsagesResponse {
  usages: UserUsageResponse[];
  username: string;
}

export type UserTemplateResponseInbounds = { [key: string]: string[] };

export interface UserTemplateResponse {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: number;
  id: number;
  inbounds?: UserTemplateResponseInbounds;
  name?: string | null;
  username_prefix?: string;
  username_suffix?: string;
}

export type UserTemplateModifyInbounds = { [key: string]: string[] };

export interface UserTemplateModify {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: number;
  inbounds?: UserTemplateModifyInbounds;
  name?: string | null;
  username_prefix?: string;
  username_suffix?: string;
}

export type UserTemplateCreateInbounds = { [key: string]: string[] };

export interface UserTemplateCreate {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: number;
  inbounds?: UserTemplateCreateInbounds;
  name?: string | null;
  username_prefix?: string;
  username_suffix?: string;
}

/**
 * An enumeration.
 */
export type UserStatusModify = (typeof UserStatusModify)[keyof typeof UserStatusModify];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatusModify = {
  active: "active",
  disabled: "disabled",
  on_hold: "on_hold",
} as const;

/**
 * An enumeration.
 */
export type UserStatusCreate = (typeof UserStatusCreate)[keyof typeof UserStatusCreate];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatusCreate = {
  active: "active",
  on_hold: "on_hold",
} as const;

/**
 * An enumeration.
 */
export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatus = {
  active: "active",
  disabled: "disabled",
  limited: "limited",
  expired: "expired",
  on_hold: "on_hold",
} as const;

export type UserResponseProxies = { [key: string]: any };

export type UserResponseInbounds = { [key: string]: string[] };

export type UserResponseExcludedInbounds = { [key: string]: string[] };

export interface UserResponse {
  created_at: string;
  /** data_limit can be 0 or greater */
  data_limit?: number;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  excluded_inbounds?: UserResponseExcludedInbounds;
  expire?: number | null;
  inbounds?: UserResponseInbounds;
  lifetime_used_traffic?: number;
  links?: string[];
  note?: string | null;
  on_hold_expire_duration?: number | null;
  on_hold_timeout?: string | null;
  online_at?: string | null;
  proxies: UserResponseProxies;
  status: UserStatus;
  sub_last_user_agent?: string | null;
  sub_updated_at?: string | null;
  subscription_url?: string;
  used_traffic: number;
  username: string;
}

export type UserModifyProxies = { [key: string]: ProxySettings };

export type UserModifyInbounds = { [key: string]: string[] };

/**
 * An enumeration.
 */
export type UserDataLimitResetStrategy = (typeof UserDataLimitResetStrategy)[keyof typeof UserDataLimitResetStrategy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserDataLimitResetStrategy = {
  no_reset: "no_reset",
  day: "day",
  week: "week",
  month: "month",
  year: "year",
} as const;

export interface UserModify {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  expire?: number | null;
  inbounds?: UserModifyInbounds;
  note?: string | null;
  on_hold_expire_duration?: number | null;
  on_hold_timeout?: string | null;
  online_at?: string | null;
  proxies?: UserModifyProxies;
  status?: UserStatusModify;
  sub_last_user_agent?: string | null;
  sub_updated_at?: string | null;
}

export type UserCreateInbounds = { [key: string]: string[] };

export interface Token {
  access_token: string;
  token_type?: string;
}

export interface SystemStats {
  cpu_cores: number;
  cpu_usage: number;
  incoming_bandwidth: number;
  incoming_bandwidth_speed: number;
  mem_total: number;
  mem_used: number;
  outgoing_bandwidth: number;
  outgoing_bandwidth_speed: number;
  total_user: number;
  users_active: number;
  version: string;
}

export interface SettingsModify {
  dashboard_path?: string;
  discord_webhook_url?: string;
  jwt_token_expire_minutes?: number;
  subscription_page_title?: string;
  subscription_support_url_header?: string;
  subscription_update_interval_header?: number;
  subscription_url_prefix?: string;
  telegram_admin_ids?: string;
  telegram_api_token?: string;
  telegram_logs_channel_id?: string;
  webhook_secret?: string;
  webhook_url?: string;
}

export interface Settings {
  dashboard_path: string;
  discord_webhook_url?: string;
  jwt_token_expire_minutes?: number;
  subscription_page_title?: string;
  subscription_support_url_header?: string;
  subscription_update_interval_header?: number;
  subscription_url_prefix?: string;
  telegram_admin_ids?: string;
  telegram_api_token?: string;
  telegram_logs_channel_id?: string;
  webhook_secret?: string;
  webhook_url?: string;
}

/**
 * An enumeration.
 */
export type ProxyTypes = (typeof ProxyTypes)[keyof typeof ProxyTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyTypes = {
  vmess: "vmess",
  vless: "vless",
  trojan: "trojan",
  shadowsocks: "shadowsocks",
} as const;

export interface ProxySettings {
  [key: string]: any;
}

export type UserCreateProxies = { [key: string]: ProxySettings };

export interface UserCreate {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  expire?: number | null;
  inbounds?: UserCreateInbounds;
  note?: string | null;
  on_hold_expire_duration?: number | null;
  on_hold_timeout?: string | null;
  online_at?: string | null;
  proxies?: UserCreateProxies;
  status?: UserStatusCreate;
  sub_last_user_agent?: string | null;
  sub_updated_at?: string | null;
  username: string;
}

export type ProxyInboundPort = number | string;

export interface ProxyInbound {
  network: string;
  port: ProxyInboundPort;
  protocol: ProxyTypes;
  tag: string;
  tls: string;
}

/**
 * An enumeration.
 */
export type ProxyHostSecurity = (typeof ProxyHostSecurity)[keyof typeof ProxyHostSecurity];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostSecurity = {
  inbound_default: "inbound_default",
  none: "none",
  tls: "tls",
} as const;

/**
 * An enumeration.
 */
export type ProxyHostFingerprint = (typeof ProxyHostFingerprint)[keyof typeof ProxyHostFingerprint];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostFingerprint = {
  "": "",
  chrome: "chrome",
  firefox: "firefox",
  safari: "safari",
  ios: "ios",
  android: "android",
  edge: "edge",
  NUMBER_360: "360",
  qq: "qq",
  random: "random",
  randomized: "randomized",
} as const;

/**
 * An enumeration.
 */
export type ProxyHostALPN = (typeof ProxyHostALPN)[keyof typeof ProxyHostALPN];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostALPN = {
  "": "",
  h2: "h2",
  "http/11": "http/1.1",
  "h2,http/11": "h2,http/1.1",
} as const;

export interface ProxyHost {
  address: string;
  allowinsecure?: boolean;
  alpn?: ProxyHostALPN;
  fingerprint?: ProxyHostFingerprint;
  host?: string | null;
  is_disabled?: boolean;
  path?: string | null;
  port?: number | null;
  remark: string;
  security?: ProxyHostSecurity;
  sni?: string | null;
}

export interface NodeUsageResponse {
  downlink: number;
  node_id?: number;
  node_name: string;
  uplink: number;
}

export interface NodesUsageResponse {
  usages: NodeUsageResponse[];
}

/**
 * An enumeration.
 */
export type NodeStatus = (typeof NodeStatus)[keyof typeof NodeStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeStatus = {
  connected: "connected",
  connecting: "connecting",
  error: "error",
  disabled: "disabled",
} as const;

export interface NodeSettings {
  certificate: string;
  min_node_version?: string;
}

export interface NodeResponse {
  address: string;
  api_port?: number;
  id: number;
  message?: string;
  name: string;
  port?: number;
  status: NodeStatus;
  usage_coefficient?: number;
  xray_version?: string;
}

export type NodeModifyStatus = NodeStatus | null;

export interface NodeModify {
  address?: string | null;
  api_port?: number | null;
  name?: string | null;
  port?: number | null;
  status?: NodeModifyStatus;
  usage_coefficient?: number | null;
}

export interface NodeCreate {
  add_as_new_host?: boolean;
  address: string;
  api_port?: number;
  name: string;
  port?: number;
  usage_coefficient?: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface CoreStats {
  logs_websocket: string;
  started: boolean;
  version: string;
}

export interface BodyAdminTokenApiAdminTokenPost {
  client_id?: string;
  client_secret?: string;
  grant_type?: string;
  password: string;
  scope?: string;
  username: string;
}

export interface AdminModify {
  is_sudo: boolean;
  password: string;
}

export interface AdminCreate {
  is_sudo: boolean;
  password: string;
  username: string;
}

export interface Admin {
  is_sudo: boolean;
  username: string;
}

/**
 * @summary Admin Token
 */
export const adminToken = (bodyAdminTokenApiAdminTokenPost: BodyType<BodyAdminTokenApiAdminTokenPost>) => {
  const formUrlEncoded = new URLSearchParams();
  if (bodyAdminTokenApiAdminTokenPost.grant_type !== undefined) {
    formUrlEncoded.append("grant_type", bodyAdminTokenApiAdminTokenPost.grant_type);
  }
  formUrlEncoded.append("username", bodyAdminTokenApiAdminTokenPost.username);
  formUrlEncoded.append("password", bodyAdminTokenApiAdminTokenPost.password);
  if (bodyAdminTokenApiAdminTokenPost.scope !== undefined) {
    formUrlEncoded.append("scope", bodyAdminTokenApiAdminTokenPost.scope);
  }
  if (bodyAdminTokenApiAdminTokenPost.client_id !== undefined) {
    formUrlEncoded.append("client_id", bodyAdminTokenApiAdminTokenPost.client_id);
  }
  if (bodyAdminTokenApiAdminTokenPost.client_secret !== undefined) {
    formUrlEncoded.append("client_secret", bodyAdminTokenApiAdminTokenPost.client_secret);
  }

  return orvalFetcher<Token>({
    url: `/api/admin/token`,
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    data: formUrlEncoded,
  });
};

export const getAdminTokenMutationOptions = <TError = ErrorType<HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminToken>>,
    TError,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminToken>>,
  TError,
  { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminToken>>,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> }
  > = (props) => {
    const { data } = props ?? {};

    return adminToken(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTokenMutationResult = NonNullable<Awaited<ReturnType<typeof adminToken>>>;
export type AdminTokenMutationBody = BodyType<BodyAdminTokenApiAdminTokenPost>;
export type AdminTokenMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Admin Token
 */
export const useAdminToken = <TError = ErrorType<HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminToken>>,
    TError,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
    TContext
  >;
}) => {
  const mutationOptions = getAdminTokenMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Current Admin
 */
export const getCurrentAdmin = (signal?: AbortSignal) => {
  return orvalFetcher<Admin>({ url: `/api/admin`, method: "GET", signal });
};

export const getGetCurrentAdminQueryKey = () => {
  return [`/api/admin`] as const;
};

export const getGetCurrentAdminQueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getCurrentAdmin>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrentAdminQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAdmin>>> = ({ signal }) => getCurrentAdmin(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentAdmin>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCurrentAdminQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentAdmin>>>;
export type GetCurrentAdminQueryError = ErrorType<unknown>;

/**
 * @summary Get Current Admin
 */
export const useGetCurrentAdmin = <
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getCurrentAdmin>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCurrentAdminQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Create Admin
 */
export const createAdmin = (adminCreate: BodyType<AdminCreate>) => {
  return orvalFetcher<Admin>({
    url: `/api/admin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminCreate,
  });
};

export const getCreateAdminMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdmin>>,
    TError,
    { data: BodyType<AdminCreate> },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createAdmin>>, TError, { data: BodyType<AdminCreate> }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdmin>>, { data: BodyType<AdminCreate> }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createAdmin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAdminMutationResult = NonNullable<Awaited<ReturnType<typeof createAdmin>>>;
export type CreateAdminMutationBody = BodyType<AdminCreate>;
export type CreateAdminMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Create Admin
 */
export const useCreateAdmin = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdmin>>,
    TError,
    { data: BodyType<AdminCreate> },
    TContext
  >;
}) => {
  const mutationOptions = getCreateAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Modify Admin
 */
export const modifyAdmin = (username: string, adminModify: BodyType<AdminModify>) => {
  return orvalFetcher<Admin>({
    url: `/api/admin/${username}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminModify,
  });
};

export const getModifyAdminMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyAdmin>>,
    TError,
    { username: string; data: BodyType<AdminModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyAdmin>>,
  TError,
  { username: string; data: BodyType<AdminModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyAdmin>>,
    { username: string; data: BodyType<AdminModify> }
  > = (props) => {
    const { username, data } = props ?? {};

    return modifyAdmin(username, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyAdminMutationResult = NonNullable<Awaited<ReturnType<typeof modifyAdmin>>>;
export type ModifyAdminMutationBody = BodyType<AdminModify>;
export type ModifyAdminMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify Admin
 */
export const useModifyAdmin = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyAdmin>>,
    TError,
    { username: string; data: BodyType<AdminModify> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Remove Admin
 */
export const removeAdmin = (username: string) => {
  return orvalFetcher<unknown>({ url: `/api/admin/${username}`, method: "DELETE" });
};

export const getRemoveAdminMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeAdmin>>, TError, { username: string }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof removeAdmin>>, TError, { username: string }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAdmin>>, { username: string }> = (props) => {
    const { username } = props ?? {};

    return removeAdmin(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveAdminMutationResult = NonNullable<Awaited<ReturnType<typeof removeAdmin>>>;

export type RemoveAdminMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove Admin
 */
export const useRemoveAdmin = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeAdmin>>, TError, { username: string }, TContext>;
}) => {
  const mutationOptions = getRemoveAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Admins
 */
export const getAdmins = (params?: GetAdminsParams, signal?: AbortSignal) => {
  return orvalFetcher<Admin[]>({ url: `/api/admins`, method: "GET", params, signal });
};

export const getGetAdminsQueryKey = (params?: GetAdminsParams) => {
  return [`/api/admins`, ...(params ? [params] : [])] as const;
};

export const getGetAdminsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  params?: GetAdminsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAdmins>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAdminsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmins>>> = ({ signal }) => getAdmins(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAdmins>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAdminsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmins>>>;
export type GetAdminsQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get Admins
 */
export const useGetAdmins = <
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  params?: GetAdminsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAdmins>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAdminsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Subscription link, V2ray and Clash supported
 * @summary User Subscription
 */
export const userSubscription = (token: string, signal?: AbortSignal) => {
  return orvalFetcher<unknown>({ url: `/sub/${token}/`, method: "GET", signal });
};

export const getUserSubscriptionQueryKey = (token: string) => {
  return [`/sub/${token}/`] as const;
};

export const getUserSubscriptionQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof userSubscription>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserSubscriptionQueryKey(token);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userSubscription>>> = ({ signal }) =>
    userSubscription(token, signal);

  return { queryKey, queryFn, enabled: !!token, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscription>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof userSubscription>>>;
export type UserSubscriptionQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary User Subscription
 */
export const useUserSubscription = <
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof userSubscription>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserSubscriptionQueryOptions(token, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary User Subscription Info
 */
export const userSubscriptionInfo = (token: string, signal?: AbortSignal) => {
  return orvalFetcher<UserResponse>({ url: `/sub/${token}/info`, method: "GET", signal });
};

export const getUserSubscriptionInfoQueryKey = (token: string) => {
  return [`/sub/${token}/info`] as const;
};

export const getUserSubscriptionInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof userSubscriptionInfo>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserSubscriptionInfoQueryKey(token);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userSubscriptionInfo>>> = ({ signal }) =>
    userSubscriptionInfo(token, signal);

  return { queryKey, queryFn, enabled: !!token, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscriptionInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserSubscriptionInfoQueryResult = NonNullable<Awaited<ReturnType<typeof userSubscriptionInfo>>>;
export type UserSubscriptionInfoQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary User Subscription Info
 */
export const useUserSubscriptionInfo = <
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof userSubscriptionInfo>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserSubscriptionInfoQueryOptions(token, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary User Get Usage
 */
export const userGetUsage = (token: string, params?: UserGetUsageParams, signal?: AbortSignal) => {
  return orvalFetcher<unknown>({ url: `/sub/${token}/usage`, method: "GET", params, signal });
};

export const getUserGetUsageQueryKey = (token: string, params?: UserGetUsageParams) => {
  return [`/sub/${token}/usage`, ...(params ? [params] : [])] as const;
};

export const getUserGetUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params?: UserGetUsageParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof userGetUsage>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserGetUsageQueryKey(token, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetUsage>>> = ({ signal }) =>
    userGetUsage(token, params, signal);

  return { queryKey, queryFn, enabled: !!token, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userGetUsage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserGetUsageQueryResult = NonNullable<Awaited<ReturnType<typeof userGetUsage>>>;
export type UserGetUsageQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary User Get Usage
 */
export const useUserGetUsage = <
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params?: UserGetUsageParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof userGetUsage>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserGetUsageQueryOptions(token, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Subscription link, v2ray, clash, sing-box, outline and clash-meta supported
 * @summary User Subscription With Client Type
 */
export const userSubscriptionWithClientType = (token: string, clientType: string, signal?: AbortSignal) => {
  return orvalFetcher<unknown>({ url: `/sub/${token}/${clientType}`, method: "GET", signal });
};

export const getUserSubscriptionWithClientTypeQueryKey = (token: string, clientType: string) => {
  return [`/sub/${token}/${clientType}`] as const;
};

export const getUserSubscriptionWithClientTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  token: string,
  clientType: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof userSubscriptionWithClientType>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserSubscriptionWithClientTypeQueryKey(token, clientType);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userSubscriptionWithClientType>>> = ({ signal }) =>
    userSubscriptionWithClientType(token, clientType, signal);

  return { queryKey, queryFn, enabled: !!(token && clientType), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserSubscriptionWithClientTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof userSubscriptionWithClientType>>
>;
export type UserSubscriptionWithClientTypeQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary User Subscription With Client Type
 */
export const useUserSubscriptionWithClientType = <
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  token: string,
  clientType: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof userSubscriptionWithClientType>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserSubscriptionWithClientTypeQueryOptions(token, clientType, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get System Stats
 */
export const getSystemStats = (signal?: AbortSignal) => {
  return orvalFetcher<SystemStats>({ url: `/api/system`, method: "GET", signal });
};

export const getGetSystemStatsQueryKey = () => {
  return [`/api/system`] as const;
};

export const getGetSystemStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSystemStatsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemStats>>> = ({ signal }) => getSystemStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSystemStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSystemStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getSystemStats>>>;
export type GetSystemStatsQueryError = ErrorType<unknown>;

/**
 * @summary Get System Stats
 */
export const useGetSystemStats = <
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getSystemStats>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetSystemStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get Inbounds
 */
export const getInbounds = (signal?: AbortSignal) => {
  return orvalFetcher<GetInbounds200>({ url: `/api/inbounds`, method: "GET", signal });
};

export const getGetInboundsQueryKey = () => {
  return [`/api/inbounds`] as const;
};

export const getGetInboundsQueryOptions = <
  TData = Awaited<ReturnType<typeof getInbounds>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getInbounds>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInboundsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInbounds>>> = ({ signal }) => getInbounds(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInbounds>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInboundsQueryResult = NonNullable<Awaited<ReturnType<typeof getInbounds>>>;
export type GetInboundsQueryError = ErrorType<unknown>;

/**
 * @summary Get Inbounds
 */
export const useGetInbounds = <TData = Awaited<ReturnType<typeof getInbounds>>, TError = ErrorType<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getInbounds>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetInboundsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get Hosts
 */
export const getHosts = (signal?: AbortSignal) => {
  return orvalFetcher<GetHosts200>({ url: `/api/hosts`, method: "GET", signal });
};

export const getGetHostsQueryKey = () => {
  return [`/api/hosts`] as const;
};

export const getGetHostsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHosts>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHostsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHosts>>> = ({ signal }) => getHosts(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHosts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHostsQueryResult = NonNullable<Awaited<ReturnType<typeof getHosts>>>;
export type GetHostsQueryError = ErrorType<void>;

/**
 * @summary Get Hosts
 */
export const useGetHosts = <TData = Awaited<ReturnType<typeof getHosts>>, TError = ErrorType<void>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetHostsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Modify Hosts
 */
export const modifyHosts = (modifyHostsBody: BodyType<ModifyHostsBody>) => {
  return orvalFetcher<ModifyHosts200>({
    url: `/api/hosts`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: modifyHostsBody,
  });
};

export const getModifyHostsMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyHosts>>,
    TError,
    { data: BodyType<ModifyHostsBody> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyHosts>>,
  TError,
  { data: BodyType<ModifyHostsBody> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof modifyHosts>>, { data: BodyType<ModifyHostsBody> }> = (
    props
  ) => {
    const { data } = props ?? {};

    return modifyHosts(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyHostsMutationResult = NonNullable<Awaited<ReturnType<typeof modifyHosts>>>;
export type ModifyHostsMutationBody = BodyType<ModifyHostsBody>;
export type ModifyHostsMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify Hosts
 */
export const useModifyHosts = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyHosts>>,
    TError,
    { data: BodyType<ModifyHostsBody> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyHostsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Settings
 */
export const getSettings = (signal?: AbortSignal) => {
  return orvalFetcher<Settings>({ url: `/api/settings`, method: "GET", signal });
};

export const getGetSettingsQueryKey = () => {
  return [`/api/settings`] as const;
};

export const getGetSettingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSettingsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSettings>>> = ({ signal }) => getSettings(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSettings>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getSettings>>>;
export type GetSettingsQueryError = ErrorType<void>;

/**
 * @summary Get Settings
 */
export const useGetSettings = <TData = Awaited<ReturnType<typeof getSettings>>, TError = ErrorType<void>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetSettingsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Put Settings
 */
export const putSettings = (settingsModify: BodyType<SettingsModify>) => {
  return orvalFetcher<Settings>({
    url: `/api/settings`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: settingsModify,
  });
};

export const getPutSettingsMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putSettings>>,
    TError,
    { data: BodyType<SettingsModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putSettings>>,
  TError,
  { data: BodyType<SettingsModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof putSettings>>, { data: BodyType<SettingsModify> }> = (
    props
  ) => {
    const { data } = props ?? {};

    return putSettings(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof putSettings>>>;
export type PutSettingsMutationBody = BodyType<SettingsModify>;
export type PutSettingsMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Put Settings
 */
export const usePutSettings = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putSettings>>,
    TError,
    { data: BodyType<SettingsModify> },
    TContext
  >;
}) => {
  const mutationOptions = getPutSettingsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Core Stats
 */
export const getCoreStats = (signal?: AbortSignal) => {
  return orvalFetcher<CoreStats>({ url: `/api/core`, method: "GET", signal });
};

export const getGetCoreStatsQueryKey = () => {
  return [`/api/core`] as const;
};

export const getGetCoreStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getCoreStats>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCoreStatsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoreStats>>> = ({ signal }) => getCoreStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCoreStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCoreStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getCoreStats>>>;
export type GetCoreStatsQueryError = ErrorType<unknown>;

/**
 * @summary Get Core Stats
 */
export const useGetCoreStats = <
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getCoreStats>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCoreStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Restart Core
 */
export const restartCore = () => {
  return orvalFetcher<unknown>({ url: `/api/core/restart`, method: "POST" });
};

export const getRestartCoreMutationOptions = <TError = ErrorType<void>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof restartCore>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof restartCore>>, TError, void, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof restartCore>>, void> = () => {
    return restartCore();
  };

  return { mutationFn, ...mutationOptions };
};

export type RestartCoreMutationResult = NonNullable<Awaited<ReturnType<typeof restartCore>>>;

export type RestartCoreMutationError = ErrorType<void>;

/**
 * @summary Restart Core
 */
export const useRestartCore = <TError = ErrorType<void>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof restartCore>>, TError, void, TContext>;
}) => {
  const mutationOptions = getRestartCoreMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Core Config
 */
export const getCoreConfig = (signal?: AbortSignal) => {
  return orvalFetcher<GetCoreConfig200>({ url: `/api/core/config`, method: "GET", signal });
};

export const getGetCoreConfigQueryKey = () => {
  return [`/api/core/config`] as const;
};

export const getGetCoreConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getCoreConfig>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCoreConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoreConfig>>> = ({ signal }) => getCoreConfig(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCoreConfig>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCoreConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getCoreConfig>>>;
export type GetCoreConfigQueryError = ErrorType<void>;

/**
 * @summary Get Core Config
 */
export const useGetCoreConfig = <
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getCoreConfig>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCoreConfigQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Modify Core Config
 */
export const modifyCoreConfig = (modifyCoreConfigBody: BodyType<ModifyCoreConfigBody>) => {
  return orvalFetcher<ModifyCoreConfig200>({
    url: `/api/core/config`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: modifyCoreConfigBody,
  });
};

export const getModifyCoreConfigMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyCoreConfig>>,
    TError,
    { data: BodyType<ModifyCoreConfigBody> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyCoreConfig>>,
  TError,
  { data: BodyType<ModifyCoreConfigBody> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyCoreConfig>>,
    { data: BodyType<ModifyCoreConfigBody> }
  > = (props) => {
    const { data } = props ?? {};

    return modifyCoreConfig(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyCoreConfigMutationResult = NonNullable<Awaited<ReturnType<typeof modifyCoreConfig>>>;
export type ModifyCoreConfigMutationBody = BodyType<ModifyCoreConfigBody>;
export type ModifyCoreConfigMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify Core Config
 */
export const useModifyCoreConfig = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyCoreConfig>>,
    TError,
    { data: BodyType<ModifyCoreConfigBody> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyCoreConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Add a new user

- **username** must have 3 to 32 characters and is allowed to contain a-z, 0-9, and underscores in between
- **expire** must be an UTC timestamp
- **data_limit** must be in Bytes, e.g. 1073741824B = 1GB
- **proxies** dictionary of protocol:settings
- **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
 * @summary Add User
 */
export const addUser = (userCreate: BodyType<UserCreate>) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userCreate,
  });
};

export const getAddUserMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addUser>>, TError, { data: BodyType<UserCreate> }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof addUser>>, TError, { data: BodyType<UserCreate> }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUser>>, { data: BodyType<UserCreate> }> = (props) => {
    const { data } = props ?? {};

    return addUser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddUserMutationResult = NonNullable<Awaited<ReturnType<typeof addUser>>>;
export type AddUserMutationBody = BodyType<UserCreate>;
export type AddUserMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Add User
 */
export const useAddUser = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addUser>>, TError, { data: BodyType<UserCreate> }, TContext>;
}) => {
  const mutationOptions = getAddUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get users information
 * @summary Get User
 */
export const getUser = (username: string, signal?: AbortSignal) => {
  return orvalFetcher<UserResponse>({ url: `/api/user/${username}`, method: "GET", signal });
};

export const getGetUserQueryKey = (username: string) => {
  return [`/api/user/${username}`] as const;
};

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  username: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(username, signal);

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>;
export type GetUserQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get User
 */
export const useGetUser = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void | HTTPValidationError>>(
  username: string,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify a user

- set **expire** to 0 to make the user unlimited in time, null to no change
- set **data_limit** to 0 to make the user unlimited in data, null to no change
- **proxies** dictionary of protocol:settings, empty means no change
- **inbounds** dictionary of protocol:inbound_tags, empty means no change
 * @summary Modify User
 */
export const modifyUser = (username: string, userModify: BodyType<UserModify>) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userModify,
  });
};

export const getModifyUserMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyUser>>,
    TError,
    { username: string; data: BodyType<UserModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyUser>>,
  TError,
  { username: string; data: BodyType<UserModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyUser>>,
    { username: string; data: BodyType<UserModify> }
  > = (props) => {
    const { username, data } = props ?? {};

    return modifyUser(username, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyUserMutationResult = NonNullable<Awaited<ReturnType<typeof modifyUser>>>;
export type ModifyUserMutationBody = BodyType<UserModify>;
export type ModifyUserMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify User
 */
export const useModifyUser = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyUser>>,
    TError,
    { username: string; data: BodyType<UserModify> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove a user
 * @summary Remove User
 */
export const removeUser = (username: string) => {
  return orvalFetcher<unknown>({ url: `/api/user/${username}`, method: "DELETE" });
};

export const getRemoveUserMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError, { username: string }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError, { username: string }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUser>>, { username: string }> = (props) => {
    const { username } = props ?? {};

    return removeUser(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserMutationResult = NonNullable<Awaited<ReturnType<typeof removeUser>>>;

export type RemoveUserMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove User
 */
export const useRemoveUser = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError, { username: string }, TContext>;
}) => {
  const mutationOptions = getRemoveUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reset user data usage
 * @summary Reset User Data Usage
 */
export const resetUserDataUsage = (username: string) => {
  return orvalFetcher<UserResponse>({ url: `/api/user/${username}/reset`, method: "POST" });
};

export const getResetUserDataUsageMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof resetUserDataUsage>>, TError, { username: string }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof resetUserDataUsage>>, TError, { username: string }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetUserDataUsage>>, { username: string }> = (
    props
  ) => {
    const { username } = props ?? {};

    return resetUserDataUsage(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetUserDataUsageMutationResult = NonNullable<Awaited<ReturnType<typeof resetUserDataUsage>>>;

export type ResetUserDataUsageMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Reset User Data Usage
 */
export const useResetUserDataUsage = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof resetUserDataUsage>>, TError, { username: string }, TContext>;
}) => {
  const mutationOptions = getResetUserDataUsageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Revoke users subscription (Subscription link and proxies)
 * @summary Revoke User Subscription
 */
export const revokeUserSubscription = (username: string) => {
  return orvalFetcher<UserResponse>({ url: `/api/user/${username}/revoke_sub`, method: "POST" });
};

export const getRevokeUserSubscriptionMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeUserSubscription>>,
    TError,
    { username: string },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof revokeUserSubscription>>, TError, { username: string }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof revokeUserSubscription>>, { username: string }> = (
    props
  ) => {
    const { username } = props ?? {};

    return revokeUserSubscription(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type RevokeUserSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof revokeUserSubscription>>>;

export type RevokeUserSubscriptionMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Revoke User Subscription
 */
export const useRevokeUserSubscription = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeUserSubscription>>,
    TError,
    { username: string },
    TContext
  >;
}) => {
  const mutationOptions = getRevokeUserSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get all users
 * @summary Get Users
 */
export const getUsers = (params?: GetUsersParams, signal?: AbortSignal) => {
  return orvalFetcher<UsersResponse>({ url: `/api/users`, method: "GET", params, signal });
};

export const getGetUsersQueryKey = (params?: GetUsersParams) => {
  return [`/api/users`, ...(params ? [params] : [])] as const;
};

export const getGetUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUsersParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>;
export type GetUsersQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get Users
 */
export const useGetUsers = <TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorType<HTTPValidationError>>(
  params?: GetUsersParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUsersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Reset all users data usage
 * @summary Reset Users Data Usage
 */
export const resetUsersDataUsage = () => {
  return orvalFetcher<unknown>({ url: `/api/users/reset`, method: "POST" });
};

export const getResetUsersDataUsageMutationOptions = <TError = ErrorType<void>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof resetUsersDataUsage>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof resetUsersDataUsage>>, TError, void, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetUsersDataUsage>>, void> = () => {
    return resetUsersDataUsage();
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetUsersDataUsageMutationResult = NonNullable<Awaited<ReturnType<typeof resetUsersDataUsage>>>;

export type ResetUsersDataUsageMutationError = ErrorType<void>;

/**
 * @summary Reset Users Data Usage
 */
export const useResetUsersDataUsage = <TError = ErrorType<void>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof resetUsersDataUsage>>, TError, void, TContext>;
}) => {
  const mutationOptions = getResetUsersDataUsageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get users usage
 * @summary Get User Usage
 */
export const getUserUsage = (username: string, params?: GetUserUsageParams, signal?: AbortSignal) => {
  return orvalFetcher<UserUsagesResponse>({ url: `/api/user/${username}/usage`, method: "GET", params, signal });
};

export const getGetUserUsageQueryKey = (username: string, params?: GetUserUsageParams) => {
  return [`/api/user/${username}/usage`, ...(params ? [params] : [])] as const;
};

export const getGetUserUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  username: string,
  params?: GetUserUsageParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserUsage>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserUsageQueryKey(username, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserUsage>>> = ({ signal }) =>
    getUserUsage(username, params, signal);

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserUsage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserUsageQueryResult = NonNullable<Awaited<ReturnType<typeof getUserUsage>>>;
export type GetUserUsageQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get User Usage
 */
export const useGetUserUsage = <
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  username: string,
  params?: GetUserUsageParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserUsage>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserUsageQueryOptions(username, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Set Owner
 */
export const setOwner = (username: string, params: SetOwnerParams) => {
  return orvalFetcher<UserResponse>({ url: `/api/user/${username}/set-owner`, method: "PUT", params });
};

export const getSetOwnerMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setOwner>>,
    TError,
    { username: string; params: SetOwnerParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setOwner>>,
  TError,
  { username: string; params: SetOwnerParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setOwner>>,
    { username: string; params: SetOwnerParams }
  > = (props) => {
    const { username, params } = props ?? {};

    return setOwner(username, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetOwnerMutationResult = NonNullable<Awaited<ReturnType<typeof setOwner>>>;

export type SetOwnerMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Set Owner
 */
export const useSetOwner = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setOwner>>,
    TError,
    { username: string; params: SetOwnerParams },
    TContext
  >;
}) => {
  const mutationOptions = getSetOwnerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete expired users
- **passed_time** must be a timestamp
- This function will delete all expired users that meet the specified number of days passed and can't be undone.
 * @summary Delete Expired
 */
export const deleteExpired = (params: DeleteExpiredParams) => {
  return orvalFetcher<unknown>({ url: `/api/users/expired`, method: "DELETE", params });
};

export const getDeleteExpiredMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExpired>>,
    TError,
    { params: DeleteExpiredParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteExpired>>,
  TError,
  { params: DeleteExpiredParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExpired>>, { params: DeleteExpiredParams }> = (
    props
  ) => {
    const { params } = props ?? {};

    return deleteExpired(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteExpiredMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExpired>>>;

export type DeleteExpiredMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Delete Expired
 */
export const useDeleteExpired = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExpired>>,
    TError,
    { params: DeleteExpiredParams },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteExpiredMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get User Templates
 */
export const getUserTemplates = (params?: GetUserTemplatesParams, signal?: AbortSignal) => {
  return orvalFetcher<UserTemplateResponse[]>({ url: `/api/user_template`, method: "GET", params, signal });
};

export const getGetUserTemplatesQueryKey = (params?: GetUserTemplatesParams) => {
  return [`/api/user_template`, ...(params ? [params] : [])] as const;
};

export const getGetUserTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUserTemplatesParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserTemplates>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserTemplatesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserTemplates>>> = ({ signal }) =>
    getUserTemplates(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTemplates>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserTemplatesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserTemplates>>>;
export type GetUserTemplatesQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get User Templates
 */
export const useGetUserTemplates = <
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUserTemplatesParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserTemplates>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserTemplatesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Add a new user template

- **name** can be up to 64 characters
- **data_limit** must be in bytes and larger or equal to 0
- **expire_duration** must be in seconds and larger or equat to 0
- **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
 * @summary Add User Template
 */
export const addUserTemplate = (userTemplateCreate: BodyType<UserTemplateCreate>) => {
  return orvalFetcher<UserTemplateResponse>({
    url: `/api/user_template`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userTemplateCreate,
  });
};

export const getAddUserTemplateMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUserTemplate>>,
    TError,
    { data: BodyType<UserTemplateCreate> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addUserTemplate>>,
  TError,
  { data: BodyType<UserTemplateCreate> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addUserTemplate>>,
    { data: BodyType<UserTemplateCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return addUserTemplate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddUserTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof addUserTemplate>>>;
export type AddUserTemplateMutationBody = BodyType<UserTemplateCreate>;
export type AddUserTemplateMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Add User Template
 */
export const useAddUserTemplate = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUserTemplate>>,
    TError,
    { data: BodyType<UserTemplateCreate> },
    TContext
  >;
}) => {
  const mutationOptions = getAddUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get User Template information with id
 * @summary Get User Template
 */
export const getUserTemplate = (id: number, signal?: AbortSignal) => {
  return orvalFetcher<UserTemplateResponse>({ url: `/api/user_template/${id}`, method: "GET", signal });
};

export const getGetUserTemplateQueryKey = (id: number) => {
  return [`/api/user_template/${id}`] as const;
};

export const getGetUserTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTemplate>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  id: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserTemplate>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserTemplateQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserTemplate>>> = ({ signal }) =>
    getUserTemplate(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTemplate>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserTemplateQueryResult = NonNullable<Awaited<ReturnType<typeof getUserTemplate>>>;
export type GetUserTemplateQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get User Template
 */
export const useGetUserTemplate = <
  TData = Awaited<ReturnType<typeof getUserTemplate>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  id: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getUserTemplate>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserTemplateQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify User Template

- **name** can be up to 64 characters
- **data_limit** must be in bytes and larger or equal to 0
- **expire_duration** must be in seconds and larger or equat to 0
- **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
 * @summary Modify User Template
 */
export const modifyUserTemplate = (id: number, userTemplateModify: BodyType<UserTemplateModify>) => {
  return orvalFetcher<UserTemplateResponse>({
    url: `/api/user_template/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userTemplateModify,
  });
};

export const getModifyUserTemplateMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyUserTemplate>>,
    TError,
    { id: number; data: BodyType<UserTemplateModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyUserTemplate>>,
  TError,
  { id: number; data: BodyType<UserTemplateModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyUserTemplate>>,
    { id: number; data: BodyType<UserTemplateModify> }
  > = (props) => {
    const { id, data } = props ?? {};

    return modifyUserTemplate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyUserTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof modifyUserTemplate>>>;
export type ModifyUserTemplateMutationBody = BodyType<UserTemplateModify>;
export type ModifyUserTemplateMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify User Template
 */
export const useModifyUserTemplate = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyUserTemplate>>,
    TError,
    { id: number; data: BodyType<UserTemplateModify> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Remove User Template
 */
export const removeUserTemplate = (id: number) => {
  return orvalFetcher<unknown>({ url: `/api/user_template/${id}`, method: "DELETE" });
};

export const getRemoveUserTemplateMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeUserTemplate>>, TError, { id: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof removeUserTemplate>>, TError, { id: number }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUserTemplate>>, { id: number }> = (props) => {
    const { id } = props ?? {};

    return removeUserTemplate(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserTemplateMutationResult = NonNullable<Awaited<ReturnType<typeof removeUserTemplate>>>;

export type RemoveUserTemplateMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove User Template
 */
export const useRemoveUserTemplate = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeUserTemplate>>, TError, { id: number }, TContext>;
}) => {
  const mutationOptions = getRemoveUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Node Settings
 */
export const getNodeSettings = (signal?: AbortSignal) => {
  return orvalFetcher<NodeSettings>({ url: `/api/node/settings`, method: "GET", signal });
};

export const getGetNodeSettingsQueryKey = () => {
  return [`/api/node/settings`] as const;
};

export const getGetNodeSettingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getNodeSettings>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeSettingsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeSettings>>> = ({ signal }) => getNodeSettings(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodeSettings>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNodeSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeSettings>>>;
export type GetNodeSettingsQueryError = ErrorType<void>;

/**
 * @summary Get Node Settings
 */
export const useGetNodeSettings = <
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getNodeSettings>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeSettingsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Add Node
 */
export const addNode = (nodeCreate: BodyType<NodeCreate>) => {
  return orvalFetcher<NodeResponse>({
    url: `/api/node`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: nodeCreate,
  });
};

export const getAddNodeMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addNode>>, TError, { data: BodyType<NodeCreate> }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof addNode>>, TError, { data: BodyType<NodeCreate> }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addNode>>, { data: BodyType<NodeCreate> }> = (props) => {
    const { data } = props ?? {};

    return addNode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddNodeMutationResult = NonNullable<Awaited<ReturnType<typeof addNode>>>;
export type AddNodeMutationBody = BodyType<NodeCreate>;
export type AddNodeMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Add Node
 */
export const useAddNode = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof addNode>>, TError, { data: BodyType<NodeCreate> }, TContext>;
}) => {
  const mutationOptions = getAddNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Node By Id
 */
export const getNodeById = (nodeId: number, signal?: AbortSignal) => {
  return orvalFetcher<NodeResponse>({ url: `/api/node/${nodeId}`, method: "GET", signal });
};

export const getGetNodeByIdQueryKey = (nodeId: number) => {
  return [`/api/node/${nodeId}`] as const;
};

export const getGetNodeByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeById>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  nodeId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNodeById>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeByIdQueryKey(nodeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeById>>> = ({ signal }) => getNodeById(nodeId, signal);

  return { queryKey, queryFn, enabled: !!nodeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodeById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNodeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeById>>>;
export type GetNodeByIdQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get Node By Id
 */
export const useGetNodeById = <
  TData = Awaited<ReturnType<typeof getNodeById>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  nodeId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNodeById>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeByIdQueryOptions(nodeId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Modify Node
 */
export const modifyNode = (nodeId: number, nodeModify: BodyType<NodeModify>) => {
  return orvalFetcher<NodeResponse>({
    url: `/api/node/${nodeId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: nodeModify,
  });
};

export const getModifyNodeMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyNode>>,
    TError,
    { nodeId: number; data: BodyType<NodeModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyNode>>,
  TError,
  { nodeId: number; data: BodyType<NodeModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyNode>>,
    { nodeId: number; data: BodyType<NodeModify> }
  > = (props) => {
    const { nodeId, data } = props ?? {};

    return modifyNode(nodeId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyNodeMutationResult = NonNullable<Awaited<ReturnType<typeof modifyNode>>>;
export type ModifyNodeMutationBody = BodyType<NodeModify>;
export type ModifyNodeMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify Node
 */
export const useModifyNode = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyNode>>,
    TError,
    { nodeId: number; data: BodyType<NodeModify> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Remove Node
 */
export const removeNode = (nodeId: number) => {
  return orvalFetcher<unknown>({ url: `/api/node/${nodeId}`, method: "DELETE" });
};

export const getRemoveNodeMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeNode>>, TError, { nodeId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof removeNode>>, TError, { nodeId: number }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeNode>>, { nodeId: number }> = (props) => {
    const { nodeId } = props ?? {};

    return removeNode(nodeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveNodeMutationResult = NonNullable<Awaited<ReturnType<typeof removeNode>>>;

export type RemoveNodeMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove Node
 */
export const useRemoveNode = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof removeNode>>, TError, { nodeId: number }, TContext>;
}) => {
  const mutationOptions = getRemoveNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Nodes
 */
export const getNodes = (signal?: AbortSignal) => {
  return orvalFetcher<NodeResponse[]>({ url: `/api/nodes`, method: "GET", signal });
};

export const getGetNodesQueryKey = () => {
  return [`/api/nodes`] as const;
};

export const getGetNodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodes>>> = ({ signal }) => getNodes(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNodesQueryResult = NonNullable<Awaited<ReturnType<typeof getNodes>>>;
export type GetNodesQueryError = ErrorType<void>;

/**
 * @summary Get Nodes
 */
export const useGetNodes = <TData = Awaited<ReturnType<typeof getNodes>>, TError = ErrorType<void>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Reconnect Node
 */
export const reconnectNode = (nodeId: number) => {
  return orvalFetcher<unknown>({ url: `/api/node/${nodeId}/reconnect`, method: "POST" });
};

export const getReconnectNodeMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof reconnectNode>>, TError, { nodeId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof reconnectNode>>, TError, { nodeId: number }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof reconnectNode>>, { nodeId: number }> = (props) => {
    const { nodeId } = props ?? {};

    return reconnectNode(nodeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReconnectNodeMutationResult = NonNullable<Awaited<ReturnType<typeof reconnectNode>>>;

export type ReconnectNodeMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Reconnect Node
 */
export const useReconnectNode = <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof reconnectNode>>, TError, { nodeId: number }, TContext>;
}) => {
  const mutationOptions = getReconnectNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get nodes usage
 * @summary Get Nodes Usage
 */
export const getNodesUsage = (params?: GetNodesUsageParams, signal?: AbortSignal) => {
  return orvalFetcher<NodesUsageResponse>({ url: `/api/nodes/usage`, method: "GET", params, signal });
};

export const getGetNodesUsageQueryKey = (params?: GetNodesUsageParams) => {
  return [`/api/nodes/usage`, ...(params ? [params] : [])] as const;
};

export const getGetNodesUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodesUsage>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  params?: GetNodesUsageParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNodesUsage>>, TError, TData> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesUsageQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodesUsage>>> = ({ signal }) =>
    getNodesUsage(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodesUsage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNodesUsageQueryResult = NonNullable<Awaited<ReturnType<typeof getNodesUsage>>>;
export type GetNodesUsageQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get Nodes Usage
 */
export const useGetNodesUsage = <
  TData = Awaited<ReturnType<typeof getNodesUsage>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  params?: GetNodesUsageParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getNodesUsage>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesUsageQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Base
 */
export const base = (signal?: AbortSignal) => {
  return orvalFetcher<string>({ url: `/`, method: "GET", signal });
};

export const getBaseQueryKey = () => {
  return [`/`] as const;
};

export const getBaseQueryOptions = <TData = Awaited<ReturnType<typeof base>>, TError = ErrorType<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBaseQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof base>>> = ({ signal }) => base(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type BaseQueryResult = NonNullable<Awaited<ReturnType<typeof base>>>;
export type BaseQueryError = ErrorType<unknown>;

/**
 * @summary Base
 */
export const useBase = <TData = Awaited<ReturnType<typeof base>>, TError = ErrorType<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getBaseQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};
