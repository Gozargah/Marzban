/**
 * Generated by orval v6.20.0 üç∫
 * Do not edit manually.
 * MarzbanAPI
 * Unified GUI Censorship Resistant Solution Powered by Xray
 * OpenAPI spec version: 0.4.1
 */
import { useMutation, useQuery } from "react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from "react-query";
import { orvalFetcher } from "../http";
import type { ErrorType, BodyType } from "../http";
export type GetUsageParams = {
  start?: string;
  end?: string;
};

export type GetUserTemplatesParams = {
  offset?: number;
  limit?: number;
};

export type DeleteExpiredParams = {
  passed_time: number;
};

export type SetOwnerParams = {
  admin_username: string;
};

export type GetUserUsageParams = {
  start?: string;
  end?: string;
};

export type GetUsersParams = {
  offset?: number;
  limit?: number;
  username?: string;
  status?: UserStatus;
  sort?: string;
};

export type ModifyCoreConfig200 = { [key: string]: any };

export type ModifyCoreConfigBody = { [key: string]: any };

export type GetCoreConfig200 = { [key: string]: any };

export type ModifyHosts200 = { [key: string]: ProxyHost[] };

export type ModifyHostsBody = { [key: string]: ProxyHost[] };

export type GetHosts200 = { [key: string]: ProxyHost[] };

export type GetInbounds200 = { [key: string]: ProxyInbound[] };

export type UserGetUsageParams = {
  start?: string;
  end?: string;
};

export type GetAdminsParams = {
  offset?: number;
  limit?: number;
  username?: string;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface UsersResponse {
  total: number;
  users: UserResponse[];
}

export interface UserUsageResponse {
  node_id?: number;
  node_name: string;
  used_traffic: number;
}

export interface UserUsagesResponse {
  usages: UserUsageResponse[];
  username: string;
}

export type UserTemplateResponseInbounds = { [key: string]: string[] };

export interface UserTemplateResponse {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: number;
  id: number;
  inbounds?: UserTemplateResponseInbounds;
  name?: string | null;
  username_prefix?: string;
  username_suffix?: string;
}

export type UserTemplateModifyInbounds = { [key: string]: string[] };

export interface UserTemplateModify {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: number;
  inbounds?: UserTemplateModifyInbounds;
  name?: string | null;
  username_prefix?: string;
  username_suffix?: string;
}

export type UserTemplateCreateInbounds = { [key: string]: string[] };

export interface UserTemplateCreate {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  /** expire_duration can be 0 or greater in seconds */
  expire_duration?: number;
  inbounds?: UserTemplateCreateInbounds;
  name?: string | null;
  username_prefix?: string;
  username_suffix?: string;
}

/**
 * An enumeration.
 */
export type UserStatusModify =
  (typeof UserStatusModify)[keyof typeof UserStatusModify];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatusModify = {
  active: "active",
  disabled: "disabled",
  on_hold: "on_hold",
} as const;

/**
 * An enumeration.
 */
export type UserStatusCreate =
  (typeof UserStatusCreate)[keyof typeof UserStatusCreate];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatusCreate = {
  active: "active",
  on_hold: "on_hold",
} as const;

/**
 * An enumeration.
 */
export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserStatus = {
  active: "active",
  disabled: "disabled",
  limited: "limited",
  expired: "expired",
  on_hold: "on_hold",
} as const;

export type UserResponseProxies = { [key: string]: any };

export type UserResponseInbounds = { [key: string]: string[] };

export type UserResponseExcludedInbounds = { [key: string]: string[] };

export interface UserResponse {
  created_at: string;
  /** data_limit can be 0 or greater */
  data_limit?: number;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  excluded_inbounds?: UserResponseExcludedInbounds;
  expire?: number | null;
  inbounds?: UserResponseInbounds;
  lifetime_used_traffic?: number;
  links?: string[];
  note?: string | null;
  on_hold_expire_duration?: number | null;
  on_hold_timeout?: string | null;
  online_at?: string | null;
  proxies: UserResponseProxies;
  status: UserStatus;
  sub_last_user_agent?: string | null;
  sub_updated_at?: string | null;
  subscription_url?: string;
  used_traffic: number;
  username: string;
}

export type UserModifyProxies = { [key: string]: ProxySettings };

export type UserModifyInbounds = { [key: string]: string[] };

/**
 * An enumeration.
 */
export type UserDataLimitResetStrategy =
  (typeof UserDataLimitResetStrategy)[keyof typeof UserDataLimitResetStrategy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserDataLimitResetStrategy = {
  no_reset: "no_reset",
  day: "day",
  week: "week",
  month: "month",
  year: "year",
} as const;

export interface UserModify {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  expire?: number | null;
  inbounds?: UserModifyInbounds;
  note?: string | null;
  on_hold_expire_duration?: number | null;
  on_hold_timeout?: string | null;
  online_at?: string | null;
  proxies?: UserModifyProxies;
  status?: UserStatusModify;
  sub_last_user_agent?: string | null;
  sub_updated_at?: string | null;
}

export type UserCreateProxies = { [key: string]: ProxySettings };

export type UserCreateInbounds = { [key: string]: string[] };

export interface UserCreate {
  /** data_limit can be 0 or greater */
  data_limit?: number;
  data_limit_reset_strategy?: UserDataLimitResetStrategy;
  expire?: number | null;
  inbounds?: UserCreateInbounds;
  note?: string | null;
  on_hold_expire_duration?: number | null;
  on_hold_timeout?: string | null;
  online_at?: string | null;
  proxies?: UserCreateProxies;
  status?: UserStatusCreate;
  sub_last_user_agent?: string | null;
  sub_updated_at?: string | null;
  username: string;
}

export interface Token {
  access_token: string;
  token_type?: string;
}

export interface SystemStats {
  cpu_cores: number;
  cpu_usage: number;
  incoming_bandwidth: number;
  incoming_bandwidth_speed: number;
  mem_total: number;
  mem_used: number;
  outgoing_bandwidth: number;
  outgoing_bandwidth_speed: number;
  total_user: number;
  users_active: number;
  version: string;
}

/**
 * An enumeration.
 */
export type ProxyTypes = (typeof ProxyTypes)[keyof typeof ProxyTypes];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyTypes = {
  vmess: "vmess",
  vless: "vless",
  trojan: "trojan",
  shadowsocks: "shadowsocks",
} as const;

export interface ProxySettings {
  [key: string]: any;
}

export type ProxyInboundPort = number | string;

export interface ProxyInbound {
  network: string;
  port: ProxyInboundPort;
  protocol: ProxyTypes;
  tag: string;
  tls: string;
}

/**
 * An enumeration.
 */
export type ProxyHostSecurity =
  (typeof ProxyHostSecurity)[keyof typeof ProxyHostSecurity];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostSecurity = {
  inbound_default: "inbound_default",
  none: "none",
  tls: "tls",
} as const;

/**
 * An enumeration.
 */
export type ProxyHostFingerprint =
  (typeof ProxyHostFingerprint)[keyof typeof ProxyHostFingerprint];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostFingerprint = {
  "": "",
  chrome: "chrome",
  firefox: "firefox",
  safari: "safari",
  ios: "ios",
  android: "android",
  edge: "edge",
  NUMBER_360: "360",
  qq: "qq",
  random: "random",
  randomized: "randomized",
} as const;

/**
 * An enumeration.
 */
export type ProxyHostALPN = (typeof ProxyHostALPN)[keyof typeof ProxyHostALPN];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProxyHostALPN = {
  "": "",
  h2: "h2",
  "http/11": "http/1.1",
  "h2,http/11": "h2,http/1.1",
} as const;

export interface ProxyHost {
  address: string;
  allowinsecure?: boolean;
  alpn?: ProxyHostALPN;
  fingerprint?: ProxyHostFingerprint;
  host?: string | null;
  is_disabled?: boolean;
  port?: number | null;
  remark: string;
  security?: ProxyHostSecurity;
  sni?: string | null;
}

export interface NodeUsageResponse {
  downlink: number;
  node_id?: number;
  node_name: string;
  uplink: number;
}

export interface NodesUsageResponse {
  usages: NodeUsageResponse[];
}

/**
 * An enumeration.
 */
export type NodeStatus = (typeof NodeStatus)[keyof typeof NodeStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeStatus = {
  connected: "connected",
  connecting: "connecting",
  error: "error",
  disabled: "disabled",
} as const;

export interface NodeSettings {
  certificate: string;
  min_node_version?: string;
}

export interface NodeResponse {
  address: string;
  api_port?: number;
  id: number;
  message?: string;
  name: string;
  port?: number;
  status: NodeStatus;
  usage_coefficient?: number;
  xray_version?: string;
}

export type NodeModifyStatus = NodeStatus | null;

export interface NodeModify {
  address?: string | null;
  api_port?: number | null;
  name?: string | null;
  port?: number | null;
  status?: NodeModifyStatus;
  usage_coefficient?: number | null;
}

export interface NodeCreate {
  add_as_new_host?: boolean;
  address: string;
  api_port?: number;
  name: string;
  port?: number;
  usage_coefficient?: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface CoreStats {
  logs_websocket: string;
  started: boolean;
  version: string;
}

export interface BodyAdminTokenApiAdminTokenPost {
  client_id?: string;
  client_secret?: string;
  grant_type?: string;
  password: string;
  scope?: string;
  username: string;
}

export interface AdminModify {
  is_sudo: boolean;
  password: string;
}

export interface AdminCreate {
  is_sudo: boolean;
  password: string;
  username: string;
}

export interface Admin {
  is_sudo: boolean;
  username: string;
}

/**
 * @summary Admin Token
 */
export const adminToken = (
  bodyAdminTokenApiAdminTokenPost: BodyType<BodyAdminTokenApiAdminTokenPost>
) => {
  const formUrlEncoded = new URLSearchParams();
  if (bodyAdminTokenApiAdminTokenPost.grant_type !== undefined) {
    formUrlEncoded.append(
      "grant_type",
      bodyAdminTokenApiAdminTokenPost.grant_type
    );
  }
  formUrlEncoded.append("username", bodyAdminTokenApiAdminTokenPost.username);
  formUrlEncoded.append("password", bodyAdminTokenApiAdminTokenPost.password);
  if (bodyAdminTokenApiAdminTokenPost.scope !== undefined) {
    formUrlEncoded.append("scope", bodyAdminTokenApiAdminTokenPost.scope);
  }
  if (bodyAdminTokenApiAdminTokenPost.client_id !== undefined) {
    formUrlEncoded.append(
      "client_id",
      bodyAdminTokenApiAdminTokenPost.client_id
    );
  }
  if (bodyAdminTokenApiAdminTokenPost.client_secret !== undefined) {
    formUrlEncoded.append(
      "client_secret",
      bodyAdminTokenApiAdminTokenPost.client_secret
    );
  }

  return orvalFetcher<Token>({
    url: `/api/admin/token`,
    method: "post",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    data: formUrlEncoded,
  });
};

export const getAdminTokenMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminToken>>,
    TError,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminToken>>,
  TError,
  { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminToken>>,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> }
  > = (props) => {
    const { data } = props ?? {};

    return adminToken(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminToken>>
>;
export type AdminTokenMutationBody = BodyType<BodyAdminTokenApiAdminTokenPost>;
export type AdminTokenMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Admin Token
 */
export const useAdminToken = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminToken>>,
    TError,
    { data: BodyType<BodyAdminTokenApiAdminTokenPost> },
    TContext
  >;
}) => {
  const mutationOptions = getAdminTokenMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Current Admin
 */
export const getCurrentAdmin = (signal?: AbortSignal) => {
  return orvalFetcher<Admin>({ url: `/api/admin`, method: "get", signal });
};

export const getGetCurrentAdminQueryKey = () => {
  return [`/api/admin`] as const;
};

export const getGetCurrentAdminQueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentAdmin>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrentAdminQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentAdmin>>> = ({
    signal,
  }) => getCurrentAdmin(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentAdmin>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCurrentAdminQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCurrentAdmin>>
>;
export type GetCurrentAdminQueryError = ErrorType<unknown>;

/**
 * @summary Get Current Admin
 */
export const useGetCurrentAdmin = <
  TData = Awaited<ReturnType<typeof getCurrentAdmin>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentAdmin>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCurrentAdminQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Create Admin
 */
export const createAdmin = (adminCreate: BodyType<AdminCreate>) => {
  return orvalFetcher<Admin>({
    url: `/api/admin`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminCreate,
  });
};

export const getCreateAdminMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdmin>>,
    TError,
    { data: BodyType<AdminCreate> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAdmin>>,
  TError,
  { data: BodyType<AdminCreate> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAdmin>>,
    { data: BodyType<AdminCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return createAdmin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAdminMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAdmin>>
>;
export type CreateAdminMutationBody = BodyType<AdminCreate>;
export type CreateAdminMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Create Admin
 */
export const useCreateAdmin = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdmin>>,
    TError,
    { data: BodyType<AdminCreate> },
    TContext
  >;
}) => {
  const mutationOptions = getCreateAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Modify Admin
 */
export const modifyAdmin = (
  username: string,
  adminModify: BodyType<AdminModify>
) => {
  return orvalFetcher<Admin>({
    url: `/api/admin/${username}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminModify,
  });
};

export const getModifyAdminMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyAdmin>>,
    TError,
    { username: string; data: BodyType<AdminModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyAdmin>>,
  TError,
  { username: string; data: BodyType<AdminModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyAdmin>>,
    { username: string; data: BodyType<AdminModify> }
  > = (props) => {
    const { username, data } = props ?? {};

    return modifyAdmin(username, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyAdminMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyAdmin>>
>;
export type ModifyAdminMutationBody = BodyType<AdminModify>;
export type ModifyAdminMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify Admin
 */
export const useModifyAdmin = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyAdmin>>,
    TError,
    { username: string; data: BodyType<AdminModify> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Remove Admin
 */
export const removeAdmin = (username: string) => {
  return orvalFetcher<unknown>({
    url: `/api/admin/${username}`,
    method: "delete",
  });
};

export const getRemoveAdminMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeAdmin>>,
    TError,
    { username: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeAdmin>>,
  TError,
  { username: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeAdmin>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return removeAdmin(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveAdminMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeAdmin>>
>;

export type RemoveAdminMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove Admin
 */
export const useRemoveAdmin = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeAdmin>>,
    TError,
    { username: string },
    TContext
  >;
}) => {
  const mutationOptions = getRemoveAdminMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Admins
 */
export const getAdmins = (params?: GetAdminsParams, signal?: AbortSignal) => {
  return orvalFetcher<Admin[]>({
    url: `/api/admins`,
    method: "get",
    params,
    signal,
  });
};

export const getGetAdminsQueryKey = (params?: GetAdminsParams) => {
  return [`/api/admins`, ...(params ? [params] : [])] as const;
};

export const getGetAdminsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  params?: GetAdminsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAdmins>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAdminsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmins>>> = ({
    signal,
  }) => getAdmins(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAdmins>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAdminsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAdmins>>
>;
export type GetAdminsQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get Admins
 */
export const useGetAdmins = <
  TData = Awaited<ReturnType<typeof getAdmins>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  params?: GetAdminsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAdmins>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAdminsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Subscription link, V2ray and Clash supported
 * @summary User Subscription
 */
export const userSubscription = (token: string, signal?: AbortSignal) => {
  return orvalFetcher<unknown>({
    url: `/sub/${token}/`,
    method: "get",
    signal,
  });
};

export const getUserSubscriptionQueryKey = (token: string) => {
  return [`/sub/${token}/`] as const;
};

export const getUserSubscriptionQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userSubscription>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserSubscriptionQueryKey(token);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userSubscription>>
  > = ({ signal }) => userSubscription(token, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!token,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscription>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserSubscriptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof userSubscription>>
>;
export type UserSubscriptionQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary User Subscription
 */
export const useUserSubscription = <
  TData = Awaited<ReturnType<typeof userSubscription>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userSubscription>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserSubscriptionQueryOptions(token, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary User Subscription Info
 */
export const userSubscriptionInfo = (token: string, signal?: AbortSignal) => {
  return orvalFetcher<UserResponse>({
    url: `/sub/${token}/info`,
    method: "get",
    signal,
  });
};

export const getUserSubscriptionInfoQueryKey = (token: string) => {
  return [`/sub/${token}/info`] as const;
};

export const getUserSubscriptionInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userSubscriptionInfo>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserSubscriptionInfoQueryKey(token);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userSubscriptionInfo>>
  > = ({ signal }) => userSubscriptionInfo(token, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!token,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscriptionInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserSubscriptionInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof userSubscriptionInfo>>
>;
export type UserSubscriptionInfoQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary User Subscription Info
 */
export const useUserSubscriptionInfo = <
  TData = Awaited<ReturnType<typeof userSubscriptionInfo>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userSubscriptionInfo>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserSubscriptionInfoQueryOptions(token, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary User Get Usage
 */
export const userGetUsage = (
  token: string,
  params?: UserGetUsageParams,
  signal?: AbortSignal
) => {
  return orvalFetcher<unknown>({
    url: `/sub/${token}/usage`,
    method: "get",
    params,
    signal,
  });
};

export const getUserGetUsageQueryKey = (
  token: string,
  params?: UserGetUsageParams
) => {
  return [`/sub/${token}/usage`, ...(params ? [params] : [])] as const;
};

export const getUserGetUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params?: UserGetUsageParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userGetUsage>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserGetUsageQueryKey(token, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetUsage>>> = ({
    signal,
  }) => userGetUsage(token, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!token,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userGetUsage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserGetUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof userGetUsage>>
>;
export type UserGetUsageQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary User Get Usage
 */
export const useUserGetUsage = <
  TData = Awaited<ReturnType<typeof userGetUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  token: string,
  params?: UserGetUsageParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userGetUsage>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserGetUsageQueryOptions(token, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Subscription link, v2ray, clash, sing-box, outline and clash-meta supported
 * @summary User Subscription With Client Type
 */
export const userSubscriptionWithClientType = (
  token: string,
  clientType: string,
  signal?: AbortSignal
) => {
  return orvalFetcher<unknown>({
    url: `/sub/${token}/${clientType}`,
    method: "get",
    signal,
  });
};

export const getUserSubscriptionWithClientTypeQueryKey = (
  token: string,
  clientType: string
) => {
  return [`/sub/${token}/${clientType}`] as const;
};

export const getUserSubscriptionWithClientTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  token: string,
  clientType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getUserSubscriptionWithClientTypeQueryKey(token, clientType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userSubscriptionWithClientType>>
  > = ({ signal }) => userSubscriptionWithClientType(token, clientType, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(token && clientType),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UserSubscriptionWithClientTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof userSubscriptionWithClientType>>
>;
export type UserSubscriptionWithClientTypeQueryError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary User Subscription With Client Type
 */
export const useUserSubscriptionWithClientType = <
  TData = Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  token: string,
  clientType: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userSubscriptionWithClientType>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserSubscriptionWithClientTypeQueryOptions(
    token,
    clientType,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get System Stats
 */
export const getSystemStats = (signal?: AbortSignal) => {
  return orvalFetcher<SystemStats>({
    url: `/api/system`,
    method: "get",
    signal,
  });
};

export const getGetSystemStatsQueryKey = () => {
  return [`/api/system`] as const;
};

export const getGetSystemStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getSystemStats>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSystemStatsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSystemStats>>> = ({
    signal,
  }) => getSystemStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSystemStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSystemStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSystemStats>>
>;
export type GetSystemStatsQueryError = ErrorType<unknown>;

/**
 * @summary Get System Stats
 */
export const useGetSystemStats = <
  TData = Awaited<ReturnType<typeof getSystemStats>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getSystemStats>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetSystemStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get Inbounds
 */
export const getInbounds = (signal?: AbortSignal) => {
  return orvalFetcher<GetInbounds200>({
    url: `/api/inbounds`,
    method: "get",
    signal,
  });
};

export const getGetInboundsQueryKey = () => {
  return [`/api/inbounds`] as const;
};

export const getGetInboundsQueryOptions = <
  TData = Awaited<ReturnType<typeof getInbounds>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getInbounds>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInboundsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInbounds>>> = ({
    signal,
  }) => getInbounds(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInbounds>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetInboundsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInbounds>>
>;
export type GetInboundsQueryError = ErrorType<unknown>;

/**
 * @summary Get Inbounds
 */
export const useGetInbounds = <
  TData = Awaited<ReturnType<typeof getInbounds>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getInbounds>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetInboundsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get Hosts
 */
export const getHosts = (signal?: AbortSignal) => {
  return orvalFetcher<GetHosts200>({
    url: `/api/hosts`,
    method: "get",
    signal,
  });
};

export const getGetHostsQueryKey = () => {
  return [`/api/hosts`] as const;
};

export const getGetHostsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHosts>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHostsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHosts>>> = ({
    signal,
  }) => getHosts(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHosts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHostsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHosts>>
>;
export type GetHostsQueryError = ErrorType<unknown>;

/**
 * @summary Get Hosts
 */
export const useGetHosts = <
  TData = Awaited<ReturnType<typeof getHosts>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getHosts>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetHostsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Modify Hosts
 */
export const modifyHosts = (modifyHostsBody: BodyType<ModifyHostsBody>) => {
  return orvalFetcher<ModifyHosts200>({
    url: `/api/hosts`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: modifyHostsBody,
  });
};

export const getModifyHostsMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyHosts>>,
    TError,
    { data: BodyType<ModifyHostsBody> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyHosts>>,
  TError,
  { data: BodyType<ModifyHostsBody> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyHosts>>,
    { data: BodyType<ModifyHostsBody> }
  > = (props) => {
    const { data } = props ?? {};

    return modifyHosts(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyHostsMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyHosts>>
>;
export type ModifyHostsMutationBody = BodyType<ModifyHostsBody>;
export type ModifyHostsMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify Hosts
 */
export const useModifyHosts = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyHosts>>,
    TError,
    { data: BodyType<ModifyHostsBody> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyHostsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Core Stats
 */
export const getCoreStats = (signal?: AbortSignal) => {
  return orvalFetcher<CoreStats>({ url: `/api/core`, method: "get", signal });
};

export const getGetCoreStatsQueryKey = () => {
  return [`/api/core`] as const;
};

export const getGetCoreStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCoreStats>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCoreStatsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoreStats>>> = ({
    signal,
  }) => getCoreStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCoreStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCoreStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCoreStats>>
>;
export type GetCoreStatsQueryError = ErrorType<unknown>;

/**
 * @summary Get Core Stats
 */
export const useGetCoreStats = <
  TData = Awaited<ReturnType<typeof getCoreStats>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCoreStats>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCoreStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Restart Core
 */
export const restartCore = () => {
  return orvalFetcher<unknown>({ url: `/api/core/restart`, method: "post" });
};

export const getRestartCoreMutationOptions = <
  TError = ErrorType<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof restartCore>>,
    TError,
    TVariables,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof restartCore>>,
  TError,
  TVariables,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof restartCore>>,
    TVariables
  > = () => {
    return restartCore();
  };

  return { mutationFn, ...mutationOptions };
};

export type RestartCoreMutationResult = NonNullable<
  Awaited<ReturnType<typeof restartCore>>
>;

export type RestartCoreMutationError = ErrorType<void>;

/**
 * @summary Restart Core
 */
export const useRestartCore = <
  TError = ErrorType<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof restartCore>>,
    TError,
    TVariables,
    TContext
  >;
}) => {
  const mutationOptions = getRestartCoreMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Core Config
 */
export const getCoreConfig = (signal?: AbortSignal) => {
  return orvalFetcher<GetCoreConfig200>({
    url: `/api/core/config`,
    method: "get",
    signal,
  });
};

export const getGetCoreConfigQueryKey = () => {
  return [`/api/core/config`] as const;
};

export const getGetCoreConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCoreConfig>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCoreConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoreConfig>>> = ({
    signal,
  }) => getCoreConfig(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCoreConfig>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCoreConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCoreConfig>>
>;
export type GetCoreConfigQueryError = ErrorType<void>;

/**
 * @summary Get Core Config
 */
export const useGetCoreConfig = <
  TData = Awaited<ReturnType<typeof getCoreConfig>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCoreConfig>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCoreConfigQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Modify Core Config
 */
export const modifyCoreConfig = (
  modifyCoreConfigBody: BodyType<ModifyCoreConfigBody>
) => {
  return orvalFetcher<ModifyCoreConfig200>({
    url: `/api/core/config`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: modifyCoreConfigBody,
  });
};

export const getModifyCoreConfigMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyCoreConfig>>,
    TError,
    { data: BodyType<ModifyCoreConfigBody> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyCoreConfig>>,
  TError,
  { data: BodyType<ModifyCoreConfigBody> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyCoreConfig>>,
    { data: BodyType<ModifyCoreConfigBody> }
  > = (props) => {
    const { data } = props ?? {};

    return modifyCoreConfig(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyCoreConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyCoreConfig>>
>;
export type ModifyCoreConfigMutationBody = BodyType<ModifyCoreConfigBody>;
export type ModifyCoreConfigMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify Core Config
 */
export const useModifyCoreConfig = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyCoreConfig>>,
    TError,
    { data: BodyType<ModifyCoreConfigBody> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyCoreConfigMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Add a new user

- **username** must have 3 to 32 characters and is allowed to contain a-z, 0-9, and underscores in between
- **expire** must be an UTC timestamp
- **data_limit** must be in Bytes, e.g. 1073741824B = 1GB
- **proxies** dictionary of protocol:settings
- **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
 * @summary Add User
 */
export const addUser = (userCreate: BodyType<UserCreate>) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: userCreate,
  });
};

export const getAddUserMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUser>>,
    TError,
    { data: BodyType<UserCreate> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addUser>>,
  TError,
  { data: BodyType<UserCreate> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addUser>>,
    { data: BodyType<UserCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return addUser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof addUser>>
>;
export type AddUserMutationBody = BodyType<UserCreate>;
export type AddUserMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Add User
 */
export const useAddUser = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUser>>,
    TError,
    { data: BodyType<UserCreate> },
    TContext
  >;
}) => {
  const mutationOptions = getAddUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get users information
 * @summary Get User
 */
export const getUser = (username: string, signal?: AbortSignal) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}`,
    method: "get",
    signal,
  });
};

export const getGetUserQueryKey = (username: string) => {
  return [`/api/user/${username}`] as const;
};

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(username, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>;
export type GetUserQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get User
 */
export const useGetUser = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  username: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify a user

- set **expire** to 0 to make the user unlimited in time, null to no change
- set **data_limit** to 0 to make the user unlimited in data, null to no change
- **proxies** dictionary of protocol:settings, empty means no change
- **inbounds** dictionary of protocol:inbound_tags, empty means no change
 * @summary Modify User
 */
export const modifyUser = (
  username: string,
  userModify: BodyType<UserModify>
) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: userModify,
  });
};

export const getModifyUserMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyUser>>,
    TError,
    { username: string; data: BodyType<UserModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyUser>>,
  TError,
  { username: string; data: BodyType<UserModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyUser>>,
    { username: string; data: BodyType<UserModify> }
  > = (props) => {
    const { username, data } = props ?? {};

    return modifyUser(username, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyUser>>
>;
export type ModifyUserMutationBody = BodyType<UserModify>;
export type ModifyUserMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify User
 */
export const useModifyUser = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyUser>>,
    TError,
    { username: string; data: BodyType<UserModify> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Remove a user
 * @summary Remove User
 */
export const removeUser = (username: string) => {
  return orvalFetcher<unknown>({
    url: `/api/user/${username}`,
    method: "delete",
  });
};

export const getRemoveUserMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUser>>,
    TError,
    { username: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeUser>>,
  TError,
  { username: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUser>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return removeUser(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUser>>
>;

export type RemoveUserMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove User
 */
export const useRemoveUser = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUser>>,
    TError,
    { username: string },
    TContext
  >;
}) => {
  const mutationOptions = getRemoveUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Reset user data usage
 * @summary Reset User Data Usage
 */
export const resetUserDataUsage = (username: string) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}/reset`,
    method: "post",
  });
};

export const getResetUserDataUsageMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetUserDataUsage>>,
    TError,
    { username: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetUserDataUsage>>,
  TError,
  { username: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetUserDataUsage>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return resetUserDataUsage(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetUserDataUsageMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetUserDataUsage>>
>;

export type ResetUserDataUsageMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Reset User Data Usage
 */
export const useResetUserDataUsage = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetUserDataUsage>>,
    TError,
    { username: string },
    TContext
  >;
}) => {
  const mutationOptions = getResetUserDataUsageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Revoke users subscription (Subscription link and proxies)
 * @summary Revoke User Subscription
 */
export const revokeUserSubscription = (username: string) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}/revoke_sub`,
    method: "post",
  });
};

export const getRevokeUserSubscriptionMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeUserSubscription>>,
    TError,
    { username: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof revokeUserSubscription>>,
  TError,
  { username: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revokeUserSubscription>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return revokeUserSubscription(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type RevokeUserSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof revokeUserSubscription>>
>;

export type RevokeUserSubscriptionMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Revoke User Subscription
 */
export const useRevokeUserSubscription = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeUserSubscription>>,
    TError,
    { username: string },
    TContext
  >;
}) => {
  const mutationOptions = getRevokeUserSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get all users
 * @summary Get Users
 */
export const getUsers = (params?: GetUsersParams, signal?: AbortSignal) => {
  return orvalFetcher<UsersResponse>({
    url: `/api/users`,
    method: "get",
    params,
    signal,
  });
};

export const getGetUsersQueryKey = (params?: GetUsersParams) => {
  return [`/api/users`, ...(params ? [params] : [])] as const;
};

export const getGetUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUsersParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUsers>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({
    signal,
  }) => getUsers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsers>>
>;
export type GetUsersQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get Users
 */
export const useGetUsers = <
  TData = Awaited<ReturnType<typeof getUsers>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUsersParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUsers>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUsersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Reset all users data usage
 * @summary Reset Users Data Usage
 */
export const resetUsersDataUsage = () => {
  return orvalFetcher<unknown>({ url: `/api/users/reset`, method: "post" });
};

export const getResetUsersDataUsageMutationOptions = <
  TError = ErrorType<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetUsersDataUsage>>,
    TError,
    TVariables,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetUsersDataUsage>>,
  TError,
  TVariables,
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetUsersDataUsage>>,
    TVariables
  > = () => {
    return resetUsersDataUsage();
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetUsersDataUsageMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetUsersDataUsage>>
>;

export type ResetUsersDataUsageMutationError = ErrorType<void>;

/**
 * @summary Reset Users Data Usage
 */
export const useResetUsersDataUsage = <
  TError = ErrorType<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetUsersDataUsage>>,
    TError,
    TVariables,
    TContext
  >;
}) => {
  const mutationOptions = getResetUsersDataUsageMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get users usage
 * @summary Get User Usage
 */
export const getUserUsage = (
  username: string,
  params?: GetUserUsageParams,
  signal?: AbortSignal
) => {
  return orvalFetcher<UserUsagesResponse>({
    url: `/api/user/${username}/usage`,
    method: "get",
    params,
    signal,
  });
};

export const getGetUserUsageQueryKey = (
  username: string,
  params?: GetUserUsageParams
) => {
  return [`/api/user/${username}/usage`, ...(params ? [params] : [])] as const;
};

export const getGetUserUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  username: string,
  params?: GetUserUsageParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserUsage>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserUsageQueryKey(username, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserUsage>>> = ({
    signal,
  }) => getUserUsage(username, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserUsage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserUsage>>
>;
export type GetUserUsageQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get User Usage
 */
export const useGetUserUsage = <
  TData = Awaited<ReturnType<typeof getUserUsage>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  username: string,
  params?: GetUserUsageParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserUsage>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserUsageQueryOptions(username, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Set Owner
 */
export const setOwner = (username: string, params: SetOwnerParams) => {
  return orvalFetcher<UserResponse>({
    url: `/api/user/${username}/set-owner`,
    method: "put",
    params,
  });
};

export const getSetOwnerMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setOwner>>,
    TError,
    { username: string; params: SetOwnerParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setOwner>>,
  TError,
  { username: string; params: SetOwnerParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setOwner>>,
    { username: string; params: SetOwnerParams }
  > = (props) => {
    const { username, params } = props ?? {};

    return setOwner(username, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetOwnerMutationResult = NonNullable<
  Awaited<ReturnType<typeof setOwner>>
>;

export type SetOwnerMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Set Owner
 */
export const useSetOwner = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setOwner>>,
    TError,
    { username: string; params: SetOwnerParams },
    TContext
  >;
}) => {
  const mutationOptions = getSetOwnerMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete expired users
- **passed_time** must be a timestamp
- This function will delete all expired users that meet the specified number of days passed and can't be undone.
 * @summary Delete Expired
 */
export const deleteExpired = (params: DeleteExpiredParams) => {
  return orvalFetcher<unknown>({
    url: `/api/users/expired`,
    method: "delete",
    params,
  });
};

export const getDeleteExpiredMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExpired>>,
    TError,
    { params: DeleteExpiredParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteExpired>>,
  TError,
  { params: DeleteExpiredParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteExpired>>,
    { params: DeleteExpiredParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteExpired(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteExpiredMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteExpired>>
>;

export type DeleteExpiredMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Delete Expired
 */
export const useDeleteExpired = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExpired>>,
    TError,
    { params: DeleteExpiredParams },
    TContext
  >;
}) => {
  const mutationOptions = getDeleteExpiredMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get User Templates
 */
export const getUserTemplates = (
  params?: GetUserTemplatesParams,
  signal?: AbortSignal
) => {
  return orvalFetcher<UserTemplateResponse[]>({
    url: `/api/user_template`,
    method: "get",
    params,
    signal,
  });
};

export const getGetUserTemplatesQueryKey = (
  params?: GetUserTemplatesParams
) => {
  return [`/api/user_template`, ...(params ? [params] : [])] as const;
};

export const getGetUserTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUserTemplatesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserTemplates>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserTemplatesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserTemplates>>
  > = ({ signal }) => getUserTemplates(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTemplates>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserTemplates>>
>;
export type GetUserTemplatesQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get User Templates
 */
export const useGetUserTemplates = <
  TData = Awaited<ReturnType<typeof getUserTemplates>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUserTemplatesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserTemplates>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserTemplatesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Add a new user template

- **name** can be up to 64 characters
- **data_limit** must be in bytes and larger or equal to 0
- **expire_duration** must be in seconds and larger or equat to 0
- **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
 * @summary Add User Template
 */
export const addUserTemplate = (
  userTemplateCreate: BodyType<UserTemplateCreate>
) => {
  return orvalFetcher<UserTemplateResponse>({
    url: `/api/user_template`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: userTemplateCreate,
  });
};

export const getAddUserTemplateMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUserTemplate>>,
    TError,
    { data: BodyType<UserTemplateCreate> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addUserTemplate>>,
  TError,
  { data: BodyType<UserTemplateCreate> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addUserTemplate>>,
    { data: BodyType<UserTemplateCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return addUserTemplate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddUserTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof addUserTemplate>>
>;
export type AddUserTemplateMutationBody = BodyType<UserTemplateCreate>;
export type AddUserTemplateMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Add User Template
 */
export const useAddUserTemplate = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUserTemplate>>,
    TError,
    { data: BodyType<UserTemplateCreate> },
    TContext
  >;
}) => {
  const mutationOptions = getAddUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get User Template information with id
 * @summary Get User Template
 */
export const getUserTemplate = (id: number, signal?: AbortSignal) => {
  return orvalFetcher<UserTemplateResponse>({
    url: `/api/user_template/${id}`,
    method: "get",
    signal,
  });
};

export const getGetUserTemplateQueryKey = (id: number) => {
  return [`/api/user_template/${id}`] as const;
};

export const getGetUserTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTemplate>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserTemplate>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserTemplateQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserTemplate>>> = ({
    signal,
  }) => getUserTemplate(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTemplate>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserTemplate>>
>;
export type GetUserTemplateQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get User Template
 */
export const useGetUserTemplate = <
  TData = Awaited<ReturnType<typeof getUserTemplate>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserTemplate>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserTemplateQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Modify User Template

- **name** can be up to 64 characters
- **data_limit** must be in bytes and larger or equal to 0
- **expire_duration** must be in seconds and larger or equat to 0
- **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
 * @summary Modify User Template
 */
export const modifyUserTemplate = (
  id: number,
  userTemplateModify: BodyType<UserTemplateModify>
) => {
  return orvalFetcher<UserTemplateResponse>({
    url: `/api/user_template/${id}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: userTemplateModify,
  });
};

export const getModifyUserTemplateMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyUserTemplate>>,
    TError,
    { id: number; data: BodyType<UserTemplateModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyUserTemplate>>,
  TError,
  { id: number; data: BodyType<UserTemplateModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyUserTemplate>>,
    { id: number; data: BodyType<UserTemplateModify> }
  > = (props) => {
    const { id, data } = props ?? {};

    return modifyUserTemplate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyUserTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyUserTemplate>>
>;
export type ModifyUserTemplateMutationBody = BodyType<UserTemplateModify>;
export type ModifyUserTemplateMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify User Template
 */
export const useModifyUserTemplate = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyUserTemplate>>,
    TError,
    { id: number; data: BodyType<UserTemplateModify> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Remove User Template
 */
export const removeUserTemplate = (id: number) => {
  return orvalFetcher<unknown>({
    url: `/api/user_template/${id}`,
    method: "delete",
  });
};

export const getRemoveUserTemplateMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUserTemplate>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeUserTemplate>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUserTemplate>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return removeUserTemplate(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUserTemplate>>
>;

export type RemoveUserTemplateMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove User Template
 */
export const useRemoveUserTemplate = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUserTemplate>>,
    TError,
    { id: number },
    TContext
  >;
}) => {
  const mutationOptions = getRemoveUserTemplateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Node Settings
 */
export const getNodeSettings = (signal?: AbortSignal) => {
  return orvalFetcher<NodeSettings>({
    url: `/api/node/settings`,
    method: "get",
    signal,
  });
};

export const getGetNodeSettingsQueryKey = () => {
  return [`/api/node/settings`] as const;
};

export const getGetNodeSettingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getNodeSettings>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeSettingsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeSettings>>> = ({
    signal,
  }) => getNodeSettings(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodeSettings>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNodeSettingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeSettings>>
>;
export type GetNodeSettingsQueryError = ErrorType<void>;

/**
 * @summary Get Node Settings
 */
export const useGetNodeSettings = <
  TData = Awaited<ReturnType<typeof getNodeSettings>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getNodeSettings>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeSettingsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Add Node
 */
export const addNode = (nodeCreate: BodyType<NodeCreate>) => {
  return orvalFetcher<NodeResponse>({
    url: `/api/node`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: nodeCreate,
  });
};

export const getAddNodeMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addNode>>,
    TError,
    { data: BodyType<NodeCreate> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addNode>>,
  TError,
  { data: BodyType<NodeCreate> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addNode>>,
    { data: BodyType<NodeCreate> }
  > = (props) => {
    const { data } = props ?? {};

    return addNode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddNodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof addNode>>
>;
export type AddNodeMutationBody = BodyType<NodeCreate>;
export type AddNodeMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Add Node
 */
export const useAddNode = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addNode>>,
    TError,
    { data: BodyType<NodeCreate> },
    TContext
  >;
}) => {
  const mutationOptions = getAddNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Node By Id
 */
export const getNodeById = (nodeId: number, signal?: AbortSignal) => {
  return orvalFetcher<NodeResponse>({
    url: `/api/node/${nodeId}`,
    method: "get",
    signal,
  });
};

export const getGetNodeByIdQueryKey = (nodeId: number) => {
  return [`/api/node/${nodeId}`] as const;
};

export const getGetNodeByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodeById>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  nodeId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeById>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodeByIdQueryKey(nodeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeById>>> = ({
    signal,
  }) => getNodeById(nodeId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!nodeId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodeById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNodeByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodeById>>
>;
export type GetNodeByIdQueryError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Get Node By Id
 */
export const useGetNodeById = <
  TData = Awaited<ReturnType<typeof getNodeById>>,
  TError = ErrorType<void | HTTPValidationError>
>(
  nodeId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getNodeById>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodeByIdQueryOptions(nodeId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Modify Node
 */
export const modifyNode = (
  nodeId: number,
  nodeModify: BodyType<NodeModify>
) => {
  return orvalFetcher<NodeResponse>({
    url: `/api/node/${nodeId}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: nodeModify,
  });
};

export const getModifyNodeMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyNode>>,
    TError,
    { nodeId: number; data: BodyType<NodeModify> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof modifyNode>>,
  TError,
  { nodeId: number; data: BodyType<NodeModify> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyNode>>,
    { nodeId: number; data: BodyType<NodeModify> }
  > = (props) => {
    const { nodeId, data } = props ?? {};

    return modifyNode(nodeId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModifyNodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof modifyNode>>
>;
export type ModifyNodeMutationBody = BodyType<NodeModify>;
export type ModifyNodeMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Modify Node
 */
export const useModifyNode = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof modifyNode>>,
    TError,
    { nodeId: number; data: BodyType<NodeModify> },
    TContext
  >;
}) => {
  const mutationOptions = getModifyNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Remove Node
 */
export const removeNode = (nodeId: number) => {
  return orvalFetcher<unknown>({
    url: `/api/node/${nodeId}`,
    method: "delete",
  });
};

export const getRemoveNodeMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeNode>>,
    TError,
    { nodeId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeNode>>,
  TError,
  { nodeId: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeNode>>,
    { nodeId: number }
  > = (props) => {
    const { nodeId } = props ?? {};

    return removeNode(nodeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveNodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeNode>>
>;

export type RemoveNodeMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove Node
 */
export const useRemoveNode = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeNode>>,
    TError,
    { nodeId: number },
    TContext
  >;
}) => {
  const mutationOptions = getRemoveNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Get Nodes
 */
export const getNodes = (signal?: AbortSignal) => {
  return orvalFetcher<NodeResponse[]>({
    url: `/api/nodes`,
    method: "get",
    signal,
  });
};

export const getGetNodesQueryKey = () => {
  return [`/api/nodes`] as const;
};

export const getGetNodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNodesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodes>>> = ({
    signal,
  }) => getNodes(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNodes>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetNodesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNodes>>
>;
export type GetNodesQueryError = ErrorType<void>;

/**
 * @summary Get Nodes
 */
export const useGetNodes = <
  TData = Awaited<ReturnType<typeof getNodes>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getNodes>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetNodesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Reconnect Node
 */
export const reconnectNode = (nodeId: number) => {
  return orvalFetcher<unknown>({
    url: `/api/node/${nodeId}/reconnect`,
    method: "post",
  });
};

export const getReconnectNodeMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reconnectNode>>,
    TError,
    { nodeId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reconnectNode>>,
  TError,
  { nodeId: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reconnectNode>>,
    { nodeId: number }
  > = (props) => {
    const { nodeId } = props ?? {};

    return reconnectNode(nodeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReconnectNodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof reconnectNode>>
>;

export type ReconnectNodeMutationError = ErrorType<void | HTTPValidationError>;

/**
 * @summary Reconnect Node
 */
export const useReconnectNode = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reconnectNode>>,
    TError,
    { nodeId: number },
    TContext
  >;
}) => {
  const mutationOptions = getReconnectNodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get nodes usage
 * @summary Get Usage
 */
export const getUsage = (params?: GetUsageParams, signal?: AbortSignal) => {
  return orvalFetcher<NodesUsageResponse>({
    url: `/api/nodes/usage`,
    method: "get",
    params,
    signal,
  });
};

export const getGetUsageQueryKey = (params?: GetUsageParams) => {
  return [`/api/nodes/usage`, ...(params ? [params] : [])] as const;
};

export const getGetUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUsageParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUsage>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsageQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsage>>> = ({
    signal,
  }) => getUsage(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsage>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsage>>
>;
export type GetUsageQueryError = ErrorType<HTTPValidationError>;

/**
 * @summary Get Usage
 */
export const useGetUsage = <
  TData = Awaited<ReturnType<typeof getUsage>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetUsageParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUsage>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUsageQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Base
 */
export const base = (signal?: AbortSignal) => {
  return orvalFetcher<string>({ url: `/`, method: "get", signal });
};

export const getBaseQueryKey = () => {
  return [`/`] as const;
};

export const getBaseQueryOptions = <
  TData = Awaited<ReturnType<typeof base>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBaseQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof base>>> = ({
    signal,
  }) => base(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof base>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type BaseQueryResult = NonNullable<Awaited<ReturnType<typeof base>>>;
export type BaseQueryError = ErrorType<unknown>;

/**
 * @summary Base
 */
export const useBase = <
  TData = Awaited<ReturnType<typeof base>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof base>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getBaseQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};
